<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Modelo Financeiro | Campo de Gás Onshore</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
  <style>
    :root { --bg:#ffffff; --text:#111827; --muted:#6b7280; --card:#ffffff; --bd:#e5e7eb; --accent:#111827; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    .wrap { max-width: 1200px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin: 0 0 4px; }
    .muted { color: var(--muted); font-size: 12px; }
    .tabs { display:inline-flex; border:1px solid var(--bd); border-radius: 14px; overflow:hidden; margin: 16px 0 20px; background:#fff; }
    .tabbtn { padding:10px 14px; font-size: 13px; border:0; background:#fff; color:#374151; cursor:pointer; }
    .tabbtn.active { background: var(--accent); color:#fff; }
    .grid { display:grid; grid-gap: 16px; }
    @media(min-width: 1024px){ .grid-3 { grid-template-columns: 1fr 2fr; } }
    .card { background: var(--card); border:1px solid var(--bd); border-radius: 14px; padding: 16px; }
    .card h2 { font-size: 16px; margin: 0 0 12px; }
    .row { margin-bottom: 14px; }
    .row label { display:flex; justify-content:space-between; font-size: 13px; margin-bottom: 6px; }
    .row input[type="range"] { width:100%; }
    .kpis { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); grid-gap: 16px; }
    .kpi { border:none; border-radius: 18px; padding: 16px; min-height: 96px; display:flex; flex-direction:column; justify-content:flex-start; color:#000; background:#f5f6f8; box-shadow:0 8px 18px rgba(15,23,42,.08); }
    .kpi .cap { font-size:11px; color:#000; text-transform:uppercase; letter-spacing:.08em; font-weight:400; }
    .kpi .val { font-size:18px; font-weight:600; margin-top:4px; color:#000; word-break:break-word; }
    .kpi .val.multi{display:flex; flex-direction:column; gap:4px;}
    .kpi.priceBox .sub { color:#000; font-weight:400; }
    .kpi-lor-ice{background:#e6f2f7;}
    .kpi-lor-celeste{background:#d6e8f5;}
    .kpi-lor-sand{background:#f4d48f;}
    .kpi-lor-blush{background:#fde7da;}
    .kpi-lor-sage{background:#d7e4d3;}
    .kpi-lor-stone{background:#e4e7ef;}
    .scenario-layout{display:flex;flex-direction:column;gap:16px;}
    .scenario-outputs{display:grid;grid-template-columns:1fr;grid-row-gap:16px;}
    .scenario-table{padding:16px;}
    @media(min-width:720px){
      .kpi{min-height:110px;}
      .kpi .val{font-size:20px;}
    }
    @media(min-width:1024px){
      .scenario-layout{display:grid;grid-template-columns:1fr 1.3fr;gap:16px;align-items:start;}
      .scenario-premissas{grid-column:1;grid-row:1 / span 2;}
      .scenario-outputs{grid-column:2;grid-row:1;}
      .scenario-table{grid-column:2;grid-row:2;}
    }
    table { width:100%; border-collapse: collapse; font-size: 12px; }
    th, td { text-align:left; padding: 8px 10px; border-top: 1px solid var(--bd); }
    .flex { display:flex; align-items:center; justify-content: space-between; }
    .small { font-size: 11px; color: var(--muted); }
    .priceBox .val { font-size:22px; font-weight:700; }
    .priceBox .sub { font-size: 11px; color: var(--muted); margin-top:4px; }
    .note { margin-top: 16px; font-size: 12px; color: var(--muted); }
    /* Otimizações para gráficos */
    .chart-scroll {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      min-width: 0; /* Evita espremimento por flex/grid */
    }
    .chart-inner {
      position: relative;
      height: 360px;
      min-width: 920px;
    }
    .chart-inner canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }
    @media(min-width: 769px) {
      .chart-inner {
        height: 420px;
        min-width: 0;
      }
    }
    @media(max-width: 768px){
      .wrap { padding: 0 12px; }
      .card { padding: 12px; }
      .card h2 { font-size: 14px; }
      .card h3 { font-size: 13px !important; margin-bottom: 12px !important; }
      /* Garantir que cards em flex/grid não espremam os gráficos */
      .card {
        min-width: 0;
      }
      .kpis { 
        grid-template-columns: repeat(2, 1fr); 
        grid-gap: 12px;
        align-items: stretch;
      }
      .kpi {
        padding: 8px 10px;
        display: flex;
        flex-direction: column;
      }
      .kpi .cap {
        font-size: 10px;
        margin-bottom: 2px;
      }
      .kpi .val {
        font-size: 15px;
        margin-top: 2px;
        line-height: 1.3;
      }
      .kpi.priceBox .sub {
        font-size: 11px;
        margin-top: 2px;
        line-height: 1.2;
      }
      .kpi .val.multi {
        gap: 2px;
      }
      /* Reorganizar ordem dos cards em mobile */
      .kpi[data-kpi-order="1"] { order: 1; } /* NPV - Linha 1 */
      .kpi[data-kpi-order="2"] { order: 2; } /* Volume médio - Linha 1 */
      .kpi[data-kpi-order="3"] { order: 3; } /* Reservas consumidas - Linha 2 */
      .kpi[data-kpi-order="4"] { order: 4; } /* Último ano - Linha 2 */
      .kpi[data-kpi-order="5"] { order: 5; } /* Preço médio - Linha 3 */
      .kpi[data-kpi-order="6"] { order: 6; } /* Margem EBITDA - Linha 3 */
      .kpi[data-kpi-order="7"] { order: 7; } /* TIR - Linha 4 */
      .kpi[data-kpi-order="8"] { order: 8; } /* EV/EBITDA implícito - Linha 4 */
      /* TIR e EV/EBITDA implícito ficam lado a lado na linha 4 */
      /* Garantir que todos os cards tenham a mesma altura usando grid */
      .kpi {
        min-height: 0;
      }
      /* Usar JavaScript para igualar altura ao preço médio */
      table { font-size: 11px; }
      th, td { padding: 6px 8px; }
    }
    @media(max-width: 480px){
      .wrap { padding: 0 8px; }
      .card { padding: 10px; }
      .card h2 { font-size: 13px; }
      .card h3 { font-size: 12px !important; margin-bottom: 10px !important; }
      table { font-size: 10px; }
      th, td { padding: 4px 6px; }
    }
    .hidden { display:none; }
    .btn { padding: 8px 12px; border:1px solid var(--bd); border-radius: 12px; background:#fff; cursor:pointer; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="flex">
      <div>
        <h1>Modelo Financeiro | Campo de Gás Onshore</h1>
        <div class="muted">Modelo nominal (com inflação). FCFE descontado a Ke. Ano inicial: 2026. Reservas totais: <span id="reserves_display">992,12</span> milhões m³.</div>
      </div>
      <button class="btn" id="resetBtn" type="button">Resetar padrões</button>
    </div>

    <div class="tabs">
      <button class="tabbtn active" id="tab-venda" type="button">Cenário 1 — Venda de gás</button>
      <button class="tabbtn" id="tab-liq" type="button">Cenário 2 — Liquefação no campo</button>
    </div>

    <!-- Cenário 1 -->
    <div id="view-venda">
      <div class="grid grid-3 scenario-layout">
        <section class="grid scenario-outputs">
          <div class="kpis">
            <div class="kpi kpi-lor-ice" data-kpi-order="1">
              <div class="cap">NPV (@Ke)</div>
              <div class="val">R$ <span id="c1_npv">0,00</span> mi</div>
            </div>
            <div class="kpi kpi-lor-celeste" data-kpi-order="2">
              <div class="cap">Volume médio do modelo</div>
              <div class="val"><span id="c1_volmed">0</span> mil m³/dia</div>
            </div>
            <div class="kpi kpi-lor-sand" data-kpi-order="3">
              <div class="cap">Reservas consumidas</div>
              <div class="val"><span id="c1_res">0,00</span> mi m³</div>
            </div>
            <div class="kpi kpi-lor-blush" data-kpi-order="4">
              <div class="cap">Último ano de operação</div>
              <div class="val"><span id="c1_lastyear">—</span></div>
            </div>
            <div class="kpi priceBox kpi-lor-sage" data-kpi-order="5">
              <div class="cap">Preço médio do modelo</div>
              <div class="val"><span id="c1_price_pct">0,0</span>% do Brent</div>
              <div class="sub">US$ <span id="c1_price_usd">0,00</span> / MMBtu</div>
              <div class="sub">R$ <span id="c1_price_brl">0,00</span> / m³</div>
            </div>
            <div class="kpi kpi-lor-sage" data-kpi-order="6">
              <div class="cap">Margem EBITDA média</div>
              <div class="val"><span id="c1_ebitda_margin">—</span></div>
            </div>
            <div class="kpi kpi-lor-stone" data-kpi-order="7">
              <div class="cap">TIR (a.a., nominal)</div>
              <div class="val"><span id="c1_irr">—</span></div>
            </div>
            <div class="kpi kpi-lor-ice" data-kpi-order="8">
              <div class="cap">EV/EBITDA implícito</div>
              <div class="val"><span id="c1_ev_ebitda">—</span></div>
              <div class="sub" style="font-size: 11px; color: var(--muted); margin-top:4px;">NPV / PV EBITDA 2028</div>
            </div>
          </div>
        </section>

        <section class="card scenario-premissas">
          <h2>Premissas — Cenário 1</h2>

          <div class="row">
            <label><span>Reservas consumidas</span><span><span id="c1_reserves_lbl">992,12</span> MMm³</span></label>
            <select id="c1_reserves" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="241.04">1P: 241,04 MMm³</option>
              <option value="362.31">1P+1C: 362,31 MMm³</option>
              <option value="576.70">1P+2C: 576,70 MMm³</option>
              <option value="992.12" selected>1P+3C: 992,12 MMm³</option>
            </select>
          </div>

          <div class="row">
            <label><span>Taxa de decaimento anual de reservas</span><span><input type="checkbox" id="c1_decay_on" style="margin-left:8px;"></span></label>
          </div>

          <div id="c1_decay_box" style="opacity:.55;pointer-events:none;">
            <div class="row">
              <label><span>Taxa de decaimento</span><span><span id="c1_decay_lbl">5.00</span>% a.a.</span></label>
              <input type="range" id="c1_decay" min="0" max="50" step="0.01" value="5">
            </div>
          </div>

          <div class="row">
            <label><span>Curva de volume</span><span><span id="c1_curve_lbl">Full</span></span></label>
            <select id="c1_curve" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="qdc">QDC</option>
              <option value="3maq">3 máquinas</option>
              <option value="qdcqdca">QDC + QDCA</option>
              <option value="full" selected>Full</option>
            </select>
          </div>

          <div class="row">
            <label><span id="c1_prod_label">Produção no cenário Full</span><span><span id="c1_prod_lbl">150</span> mil m³/dia</span></label>
            <input type="range" id="c1_prod" min="0" max="150" step="1" value="150">
          </div>

          <div class="row">
            <label><span>Modelo</span><span><span id="c1_model_lbl">Nominal</span></span></label>
            <select id="c1_model" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="nominal" selected>Nominal</option>
              <option value="real">Real</option>
            </select>
          </div>

          <div class="row">
            <label><span>Cenário de preço</span><span><span id="c1_price_scenario_lbl">Default</span></span></label>
            <select id="c1_price_scenario" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="default" selected>Default (R$ 2,3608/m³)</option>
              <option value="renegociado">Renegociado (R$ 1,90/m³)</option>
              <option value="brent">% Brent</option>
            </select>
          </div>

          <div class="row">
            <label><span>Cenário de Brent</span><span><span id="c1_brent_scenario_lbl">Curva forward</span></span></label>
            <select id="c1_brent_scenario" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="forward" selected>Curva forward</option>
              <option value="bloomberg">Média Bloomberg</option>
              <option value="custom">Customizado</option>
            </select>
          </div>

          <div id="c1_brent_custom_box" style="display:none;">
          <div class="row">
            <label><span>Brent (US$/bbl)</span><span>US$ <span id="c1_brent_lbl">66.90</span></span></label>
            <input type="range" id="c1_brent" min="50" max="95" step="0.1" value="62.0">
          </div>
          </div>

          <div id="c1_brent_price_box" style="display:none;">
          <div class="row">
              <label><span>Preço de venda (% do Brent)</span><span><span id="c1_pct_lbl">10.0</span>%</span></label>
              <input type="range" id="c1_pct" min="0" max="15" step="0.1" value="10">
              <div class="small">Brent: US$ <span id="c1_brent_lbl2">62.00</span> / bbl → preço gás ≈ US$ <span id="c1_price_usd_lbl">6.20</span> / MMBtu</div>
            </div>
          </div>


          <div class="row">
            <label><span>Custo de abandono (R$ mi)</span><span>R$ <span id="c1_abd_lbl">50.00</span></span></label>
            <input type="range" id="c1_abd" min="0" max="100" step="0.5" value="50">
          </div>

          <div class="row">
            <label><span>CapEx (R$ mi, ano 1)</span><span>R$ <span id="c1_capex_lbl">0.00</span></span></label>
            <input type="range" id="c1_capex" min="0" max="50" step="0.1" value="0">
          </div>

          <div class="row">
            <label><span>Preço de compra (R$ mi, t0)</span><span>R$ <span id="c1_buy_lbl">0.00</span></span></label>
            <input type="range" id="c1_buy" min="0" max="120" step="0.1" value="0">
          </div>

          <div class="row">
            <label><span>Ke (real)</span><span><span id="c1_ke_lbl">25.0</span>%</span></label>
            <input type="range" id="c1_ke" min="0" max="50" step="0.1" value="25">
          </div>
        </section>

        <section class="card scenario-table">
          <div class="flex">
            <h3 style="margin:0;font-size:14px;">Fluxo de Caixa (R$ milhões, nominais)</h3>
            <div class="small">Ano parcial proporcional; desconto por fração.</div>
          </div>
          <div style="overflow:auto; margin-top:8px;">
            <table>
              <thead>
                <tr>
                  <th>Ano</th><th>Fraç.</th><th>Reservas restantes</th><th>Produção média (m³/dia)</th><th>Preço médio (R$/m³)</th><th>Receita</th><th>Royalties</th><th>EBITDA</th><th>Aband.</th><th>Impostos</th><th>Capex</th><th>FCFE</th><th>PV</th>
                </tr>
              </thead>
              <tbody id="c1_tbody">
                <tr><td colspan="10" class="small">Sem dados.</td></tr>
              </tbody>
            </table>
          </div>
        </section>
      </div>
      <div class="note">Notas: (i) preços em US$/MMBtu derivados do Brent (%); (ii) receita bruta = volume × preço / (1 - 9,25% gross-up PIS/COFINS); (iii) receita líquida = receita bruta - tributos sobre faturamento (10,65% em lucro presumido ou 16,25% em lucro real, conforme receita bruta do ano anterior > R$ 78 milhões); (iv) royalties 5,5% da receita bruta; (v) tributos sobre lucro: lucro real = 34% sobre EBT; lucro presumido = 3,08% da receita bruta (IRPJ: 2% + CSLL: 1,08%); (vi) NPV em R$ milhões; (vii) produção limitada a <span id="c1_reserves_note">470,00</span> MMm³; (viii) COGS base de R$ 2.463.662,60/ano, atualizado anualmente em janeiro, proporcional à fração do ano; (ix) SG&A base de R$ 2.301.987,22/ano, atualizado anualmente em janeiro, proporcional à fração do ano; (x) Preço base de R$ 2,3608/m³, atualizado anualmente em junho; (xi) Leasing de R$ 3,6 milhões/ano (despesa financeira), proporcional à fração do ano; (xii) Maintenance CapEx de 0,5% da receita bruta; (xiii) EBITDA = Receita líquida - Royalties - COGS - SG&A; (xiv) EBT = EBITDA - Leasing; (xv) corte econômico: produção finaliza se lucro líquido mensal < R$ 500 mil (base 2026), ajustado pela inflação anualmente em janeiro.</div>
    </div>

    <!-- Cenário 2 -->
    <div id="view-liq" class="hidden">
      <div class="grid grid-3 scenario-layout">
        <section class="grid scenario-outputs">
          <div class="kpis">
            <div class="kpi kpi-lor-ice" data-kpi-order="1">
              <div class="cap">NPV (@Ke) — desalav. / alav.</div>
              <div class="val multi">
                <span>Desalav.: R$ <span id="c2_npv_unlev">0,00</span> mi</span>
                <span>Alav.: R$ <span id="c2_npv_lev">0,00</span> mi</span>
              </div>
            </div>
            <div class="kpi kpi-lor-celeste" data-kpi-order="2">
              <div class="cap">Volume médio do modelo</div>
              <div class="val"><span id="c2_volmed">0</span> mil m³/dia</div>
            </div>
            <div class="kpi kpi-lor-sand" data-kpi-order="3">
              <div class="cap">Reservas consumidas</div>
              <div class="val"><span id="c2_res">0,00</span> mi m³</div>
            </div>
            <div class="kpi kpi-lor-blush" data-kpi-order="4">
              <div class="cap">Último ano de operação</div>
              <div class="val"><span id="c2_lastyear">—</span></div>
            </div>
            <div class="kpi priceBox kpi-lor-sage" data-kpi-order="5">
              <div class="cap">Preço médio do modelo</div>
              <div class="val"><span id="c2_price_pct">0,0</span>% do Brent</div>
              <div class="sub">US$ <span id="c2_price_usd">0,00</span> / MMBtu</div>
              <div class="sub">R$ <span id="c2_price_brl">0,00</span> / m³</div>
            </div>
            <div class="kpi kpi-lor-sage" data-kpi-order="6">
              <div class="cap">Margem EBITDA média</div>
              <div class="val"><span id="c2_ebitda_margin">—</span></div>
            </div>
            <div class="kpi kpi-lor-stone" data-kpi-order="7">
              <div class="cap">TIR (desalav. / alav.)</div>
              <div class="val"><span id="c2_irr_unlev">—</span> / <span id="c2_irr_lev">—</span></div>
            </div>
            <div class="kpi kpi-lor-ice" data-kpi-order="8">
              <div class="cap">EV/EBITDA implícito</div>
              <div class="val"><span id="c2_ev_ebitda">—</span></div>
              <div class="sub" style="font-size: 11px; color: var(--muted); margin-top:4px;">NPV / PV EBITDA 2028</div>
            </div>
          </div>
        </section>

        <section class="card scenario-premissas">
          <h2>Premissas — Cenário 2 (Liquefação)</h2>

          <div class="row">
            <label><span>Reservas consumidas</span><span><span id="c2_reserves_lbl">992,12</span> MMm³</span></label>
            <select id="c2_reserves" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="241.04">1P: 241,04 MMm³</option>
              <option value="362.31">1P+1C: 362,31 MMm³</option>
              <option value="576.70">1P+2C: 576,70 MMm³</option>
              <option value="992.12" selected>1P+3C: 992,12 MMm³</option>
            </select>
          </div>

          <div class="row">
            <label><span>Taxa de decaimento anual de reservas</span><span><input type="checkbox" id="c2_decay_on" style="margin-left:8px;"></span></label>
          </div>

          <div id="c2_decay_box" style="opacity:.55;pointer-events:none;">
            <div class="row">
              <label><span>Taxa de decaimento</span><span><span id="c2_decay_lbl">5.00</span>% a.a.</span></label>
              <input type="range" id="c2_decay" min="0" max="50" step="0.01" value="5">
            </div>
          </div>

          <div class="row">
            <label><span>Curva de volume</span><span><span id="c2_curve_lbl">Full</span></span></label>
            <select id="c2_curve" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="qdc">QDC</option>
              <option value="3maq">3 máquinas</option>
              <option value="qdcqdca">QDC + QDCA</option>
              <option value="full" selected>Full</option>
            </select>
          </div>

          <div class="row">
            <label><span id="c2_prod_label">Produção no cenário Full</span><span><span id="c2_prod_lbl">150</span> mil m³/dia</span></label>
            <input type="range" id="c2_prod" min="0" max="150" step="1" value="150">
          </div>

          <div class="row">
            <label><span>Modelo</span><span><span id="c2_model_lbl">Nominal</span></span></label>
            <select id="c2_model" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="nominal" selected>Nominal</option>
              <option value="real">Real</option>
            </select>
          </div>

          <div class="row">
            <label><span>Cenário de preço</span><span><span id="c2_price_scenario_lbl">Default</span></span></label>
            <select id="c2_price_scenario" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="default" selected>Default (R$ 2,3608/m³)</option>
              <option value="renegociado">Renegociado (R$ 1,90/m³)</option>
              <option value="brent">% Brent</option>
            </select>
          </div>

          <div class="row">
            <label><span>Cenário de Brent</span><span><span id="c2_brent_scenario_lbl">Curva forward</span></span></label>
            <select id="c2_brent_scenario" style="width:100%; padding:8px; border:1px solid var(--bd); border-radius:8px; font-size:13px;">
              <option value="forward" selected>Curva forward</option>
              <option value="bloomberg">Média Bloomberg</option>
              <option value="custom">Customizado</option>
            </select>
          </div>

          <div id="c2_brent_custom_box" style="display:none;">
          <div class="row">
            <label><span>Brent (US$/bbl)</span><span>US$ <span id="c2_brent_lbl">66.90</span></span></label>
            <input type="range" id="c2_brent" min="40" max="100" step="0.1" value="62.0">
          </div>
          </div>

          <div id="c2_brent_price_box" style="display:none;">
          <div class="row">
              <label><span>Preço de venda (% do Brent)</span><span><span id="c2_pct_lbl">25.0</span>%</span></label>
              <input type="range" id="c2_pct" min="0" max="32" step="0.1" value="25">
              <div class="small">Brent: US$ <span id="c2_brent_lbl2">62.00</span> / bbl → preço gás ≈ US$ <span id="c2_price_usd_lbl">15.50</span> / MMBtu</div>
            </div>
          </div>


          <div class="row">
            <label><span>Custo de abandono (R$ mi)</span><span>R$ <span id="c2_abd_lbl">50.00</span></span></label>
            <input type="range" id="c2_abd" min="0" max="100" step="0.5" value="50">
          </div>

          <div class="row">
            <label><span>CapEx (R$ mi)</span><span>R$ <span id="c2_capex_lbl">120.00</span></span></label>
            <input type="range" id="c2_capex" min="0" max="150" step="0.5" value="120">
          </div>

          <div class="row">
            <label><span>Construção / início (meses)</span><span><span id="c2_build_lbl">12</span></span></label>
            <input type="range" id="c2_build" min="0" max="36" step="1" value="12">
            <div class="small">CapEx dividido igualmente entre os meses de construção.</div>
          </div>

          <div class="row">
            <label><span>Modelo alavancado?</span><span><input type="checkbox" id="c2_debt_on"></span></label>
          </div>

          <div id="debt_box" style="opacity:.55;pointer-events:none;">
            <div class="row">
              <label><span>% do CapEx financiado</span><span><span id="c2_debt_pct_lbl">80</span>%</span></label>
              <input type="range" id="c2_debt_pct" min="0" max="100" step="1" value="80">
            </div>

            <div class="row">
              <label><span>Carência (meses)</span><span><span id="c2_grace_lbl">12</span></span></label>
              <input type="range" id="c2_grace" min="0" max="24" step="1" value="12">
            </div>

            <div class="row">
              <label><span>Vencimento (meses, incl. carência)</span><span><span id="c2_maturity_lbl">60</span></span></label>
              <input type="range" id="c2_maturity" min="0" max="120" step="1" value="60">
            </div>

            <div class="row">
              <label><span>Custo da dívida (a.a.)</span><span><span id="c2_rate_lbl">9.0</span>%</span></label>
              <input type="range" id="c2_rate" min="0" max="15" step="0.1" value="9">
            </div>
          </div>

          <div class="row">
            <label><span>Ke (real)</span><span><span id="c2_ke_lbl">25.0</span>%</span></label>
            <input type="range" id="c2_ke" min="0" max="50" step="0.1" value="25">
          </div>

          <div class="small">Royalties 5,5% sobre receita; depreciação linear 10 anos; tributos 34% do EBT; dívida emitida conforme CapEx; vencimento inclui carência.</div>
        </section>

        <section class="card scenario-table">
          <div class="flex">
            <h3 style="margin:0;font-size:14px;">Fluxo de Caixa (R$ milhões, nominais)</h3>
            <div class="small">Resumo anual equivalente; fração ajusta último ano.</div>
          </div>
          <div style="overflow:auto; margin-top:8px;">
            <table>
              <thead>
                <tr>
                  <th>Ano</th><th>Fraç.</th><th>Reservas restantes</th><th>Produção média (m³/dia)</th><th>Preço médio (R$/m³)</th><th>Receita</th><th>Royalties</th><th>EBITDA</th><th>Aband.</th><th>Impostos</th><th>Capex</th><th>FCFE</th><th>PV</th>
                </tr>
              </thead>
              <tbody id="c2_tbody">
                <tr><td colspan="10" class="small">Sem dados.</td></tr>
              </tbody>
            </table>
          </div>
        </section>
      </div>
      <div class="note">Notas: (i) preços em US$/MMBtu derivados do Brent (%); (ii) receita bruta = volume × preço / (1 - 9,25% gross-up PIS/COFINS); (iii) receita líquida = receita bruta - tributos sobre faturamento (10,65% em lucro presumido ou 16,25% em lucro real, conforme receita bruta do ano anterior > R$ 78 milhões); (iv) royalties 5,5% da receita bruta; (v) tributos sobre lucro: lucro real = 34% sobre EBT; lucro presumido = 3,08% da receita bruta (IRPJ: 2% + CSLL: 1,08%); (vi) depreciação linear 10 anos; (vii) NPV em R$ milhões; (viii) produção limitada a <span id="c2_reserves_note">470,00</span> MMm³; (ix) COGS base de R$ 2.463.662,60/ano, atualizado anualmente em janeiro, proporcional ao mês; (x) SG&A base de R$ 2.301.987,22/ano, atualizado anualmente em janeiro, proporcional ao mês; (xi) Preço base de R$ 2,3608/m³, atualizado anualmente em junho; (xii) Leasing de R$ 3,6 milhões/ano (despesa financeira), proporcional ao mês; (xiii) Maintenance CapEx de 0,5% da receita bruta; (xiv) EBITDA = Receita líquida - Royalties - COGS - SG&A; (xv) EBT = EBITDA - Depreciação - Leasing; (xvi) corte econômico: produção finaliza se lucro líquido < R$ 500 mil/mês (base 2026), ajustado pela inflação anualmente em janeiro.</div>
    </div>
  </div>

  <!-- Seção de Gráficos -->
  <div class="wrap" style="margin-top: 32px;">
    <div class="card">
      <h2>Gráficos de Produção</h2>
      <div style="margin-top: 16px;">
        <div class="card" style="padding: 20px;">
          <h3 style="font-size: 14px; margin: 0 0 16px; font-weight: 600;">Volume Médio Diário por Ano (2026-2040)</h3>
          <div class="chart-scroll">
            <div class="chart-inner" id="volumeChartContainer">
              <canvas id="volumeChart"></canvas>
            </div>
          </div>
        </div>
        <div class="card" style="padding: 20px; margin-top: 16px;">
          <h3 style="font-size: 14px; margin: 0 0 16px; font-weight: 600;">Reservas por Ano (2026-2040)</h3>
          <div class="chart-scroll">
            <div class="chart-inner" id="reservesChartContainer">
              <canvas id="reservesChart"></canvas>
            </div>
          </div>
        </div>
        <div class="card" style="padding: 20px; margin-top: 16px;">
          <h3 style="font-size: 14px; margin: 0 0 16px; font-weight: 600;">Receita Líquida e Margem EBITDA (2026-2040)</h3>
          <div class="chart-scroll">
            <div class="chart-inner" id="revenueChartContainer">
              <canvas id="revenueChart"></canvas>
            </div>
          </div>
        </div>
        <div class="card" style="padding: 20px; margin-top: 16px;">
          <h3 style="font-size: 14px; margin: 0 0 16px; font-weight: 600;">FCFE Acumulado (2026-2040)</h3>
          <div class="chart-scroll">
            <div class="chart-inner" id="fcfeChartContainer">
              <canvas id="fcfeChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Constantes ----------
    var USD_BRL = 5.5, M3_PER_MMBTU = 26.8081, ROYALTY_RATE = 0.055, TAX_RATE = 0.34, START_YEAR = 2026;
    
    // Anos bissextos (fevereiro com 29 dias, ano com 366 dias)
    var LEAP_YEARS = [2028, 2032, 2036, 2040, 2044, 2048, 2052, 2056, 2060];
    
    // Função para verificar se um ano é bissexto
    function isLeapYear(year) {
      return LEAP_YEARS.indexOf(year) !== -1;
    }
    
    // Função para obter o número de dias em um mês (1-12)
    function getDaysInMonth(month, year) {
      // month: 1 = Janeiro, 2 = Fevereiro, ..., 12 = Dezembro
      var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var days = daysInMonth[month - 1];
      
      // Se for fevereiro (mês 2) e o ano for bissexto, retornar 29 dias
      if(month === 2 && year && isLeapYear(year)) {
        days = 29;
      }
      
      return days;
    }
    
    // Função para obter o número total de dias no ano
    function getDaysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    var COGS_ANUAL_BASE = 2463662.60234372; // R$ 2.463.662,60234372/ano (base)
    var SGA_ANUAL_BASE = 2301987.21909101; // R$ 2.301.987,21909101/ano (base)
    var LEASING_ANUAL = 3600000; // R$ 3,6 milhões/ano
    var MAINTENANCE_CAPEX_RATE = 0.005; // 0,5% da receita
    var MIN_PROFIT_THRESHOLD_BASE = 500000; // R$ 500 mil (corte econômico base, ano 2026)
    
    // Função para calcular valor do corte econômico ajustado pela inflação
    // isRealModel: se true, retorna MIN_PROFIT_THRESHOLD_BASE sem inflação
    function getMinProfitThreshold(year, month, isRealModel) {
      // Usar a mesma inflação do COGS/SG&A (atualização em janeiro)
      var factor = getCogsSgaInflationFactor(year, month, isRealModel);
      return MIN_PROFIT_THRESHOLD_BASE * factor;
    }
    
    // Constantes para cálculo de receita
    var GROSS_UP_PIS_COFINS = 0.0925; // 9,25% de gross-up (PIS/COFINS)
    var TAX_RATE_PRESUMIDO = 0.1065; // 10,65% - Tributos sobre faturamento (lucro presumido)
    var TAX_RATE_REAL = 0.1625; // 16,25% - Tributos sobre faturamento (lucro real)
    var REVENUE_THRESHOLD_FOR_REAL = 78000000; // R$ 78.000.000 - Limite para lucro real
    
    // Constantes para tributos sobre lucro (lucro presumido)
    var PRESUMIDO_EBT_RATE_IRPJ = 0.08; // 8,0% da receita bruta para IRPJ
    var PRESUMIDO_IRPJ_RATE = 0.25; // 25% de alíquota de IRPJ
    var PRESUMIDO_EBT_RATE_CSLL = 0.12; // 12,0% da receita bruta para CSLL
    var PRESUMIDO_CSLL_RATE = 0.09; // 9,0% de alíquota de CSLL
    
    // Função para calcular receita bruta (com gross-up)
    function calculateGrossRevenue(volumeM3, pricePerM3) {
      // Receita bruta = (Volume × Preço) / (1 - gross-up)
      // O gross-up de 9,25% é aplicado dividindo por (1 - 0,0925) = 0,9075
      var revenueWithoutGrossUp = volumeM3 * pricePerM3;
      return revenueWithoutGrossUp / (1 - GROSS_UP_PIS_COFINS);
    }
    
    // Função para determinar regime tributário baseado na receita bruta do ano anterior
    function determineTaxRegime(previousYearGrossRevenue) {
      // Se não há receita do ano anterior (primeiro ano), usar lucro presumido como padrão
      if(!previousYearGrossRevenue || previousYearGrossRevenue === 0) {
        return false; // false = lucro presumido
      }
      // Se receita bruta do ano anterior > R$ 78.000.000, usar lucro real
      return previousYearGrossRevenue > REVENUE_THRESHOLD_FOR_REAL;
    }
    
    // Função para calcular tributos sobre faturamento
    function calculateTurnoverTaxes(grossRevenue, isLucroReal) {
      var taxRate = isLucroReal ? TAX_RATE_REAL : TAX_RATE_PRESUMIDO;
      return grossRevenue * taxRate;
    }
    
    // Função para calcular tributos sobre lucro (EBT)
    function calculateProfitTaxes(ebt, grossRevenue, isLucroReal) {
      if(isLucroReal) {
        // Lucro real: 34% sobre EBT
        return ebt > 0 ? ebt * TAX_RATE : 0;
      } else {
        // Lucro presumido:
        // IRPJ: 8% da receita bruta × 25% = 2% da receita bruta
        // CSLL: 12% da receita bruta × 9% = 1,08% da receita bruta
        // Total: 3,08% da receita bruta
        var irpj = grossRevenue * PRESUMIDO_EBT_RATE_IRPJ * PRESUMIDO_IRPJ_RATE;
        var csll = grossRevenue * PRESUMIDO_EBT_RATE_CSLL * PRESUMIDO_CSLL_RATE;
        return irpj + csll;
      }
    }
    
    // Função para calcular receita líquida
    function calculateNetRevenue(volumeM3, pricePerM3, isLucroReal) {
      var grossRevenue = calculateGrossRevenue(volumeM3, pricePerM3);
      var turnoverTaxes = calculateTurnoverTaxes(grossRevenue, isLucroReal);
      return grossRevenue - turnoverTaxes;
    }
    
    // Função para calcular taxa de inflação do ano (baseada na inflação do preço aplicada em junho)
    // isRealModel: se true, retorna 0 (sem inflação)
    function getAverageInflationForYear(year, isRealModel) {
      // Se modelo real, não aplicar inflação
      if(isRealModel) {
        return 0;
      }
      
      // Obter a taxa de inflação que será aplicada em junho deste ano
      var inflationRate = 0;
      
      if(year === 2026) {
        inflationRate = PRICE_INFLATION_2026;
      } else if(year === 2027) {
        inflationRate = PRICE_INFLATION_2027;
      } else if(year === 2028) {
        inflationRate = PRICE_INFLATION_2028;
      } else if(year >= 2029) {
        inflationRate = PRICE_INFLATION_DEFAULT;
      }
      
      // A inflação é aplicada em junho, então para o cálculo do Ke nominal do ano,
      // usamos a taxa de inflação que será aplicada naquele ano
      return inflationRate;
    }
    
    // Função para calcular Ke nominal baseado no Ke real e na inflação do ano
    // isRealModel: se true, retorna keReal (sem ajuste por inflação)
    function calculateNominalKe(keReal, year, isRealModel) {
      // Se modelo real, não aplicar inflação no custo de capital
      if(isRealModel) {
        return keReal;
      }
      var inflation = getAverageInflationForYear(year, isRealModel);
      // Ke nominal = (1 + Ke real) × (1 + inflação) - 1
      return (1 + keReal) * (1 + inflation) - 1;
    }
    
    // Preço base de venda
    var PRICE_BASE = 2.3608; // R$ 2,3608/m³ (base)
    
    // Taxas de inflação para preço de venda (atualização em junho)
    var PRICE_INFLATION_2026 = 0.0355298903635566; // 3,55298903635566%
    var PRICE_INFLATION_2027 = 0.0398982642547305; // 3,98982642547305%
    var PRICE_INFLATION_2028 = 0.0364989146159298; // 3,64989146159298%
    var PRICE_INFLATION_DEFAULT = 0.035; // 3,50% (a partir de 2029)
    
    // Taxas de inflação para COGS e SG&A (atualização em janeiro)
    var COGS_INFLATION_2027 = 0.0414828026974459; // 4,14828026974459%
    var COGS_INFLATION_2028 = 0.0377496682215077; // 3,77496682215077%
    var COGS_INFLATION_DEFAULT = 0.035; // 3,50% (a partir de 2029)
    
    // Função para calcular fator de inflação acumulado do preço até um determinado ano/mês
    // isRealModel: se true, retorna 1.0 (sem inflação)
    function getPriceInflationFactor(year, month, isRealModel) {
      // Se modelo real, não aplicar inflação
      if(isRealModel) {
        return 1.0;
      }
      
      var factor = 1.0;
      
      // Aplicar inflação de junho/2026 se já passou
      if(year > 2026 || (year === 2026 && month >= 6)) {
        factor *= (1 + PRICE_INFLATION_2026);
      }
      
      // Aplicar inflação de junho/2027 se já passou
      if(year > 2027 || (year === 2027 && month >= 6)) {
        factor *= (1 + PRICE_INFLATION_2027);
      }
      
      // Aplicar inflação de junho/2028 se já passou
      if(year > 2028 || (year === 2028 && month >= 6)) {
        factor *= (1 + PRICE_INFLATION_2028);
      }
      
      // Aplicar inflação de junho/2029 se já passou
      if(year > 2029 || (year === 2029 && month >= 6)) {
        factor *= (1 + PRICE_INFLATION_DEFAULT);
      }
      
      // Aplicar inflação de junho para cada ano após 2029
      if(year > 2029) {
        for(var y = 2030; y <= year; y++) {
          // Aplicar inflação se já passou de junho no ano atual, ou se é um ano anterior
          if(y < year || (y === year && month >= 6)) {
            factor *= (1 + PRICE_INFLATION_DEFAULT);
          }
        }
      }
      
      return factor;
    }
    
    // Função para calcular fator de inflação acumulado do COGS/SG&A até um determinado ano/mês
    // isRealModel: se true, retorna 1.0 (sem inflação)
    function getCogsSgaInflationFactor(year, month, isRealModel) {
      // Se modelo real, não aplicar inflação
      if(isRealModel) {
        return 1.0;
      }
      
      var factor = 1.0;
      
      // Aplicar inflação de janeiro/2027 se já passou
      if(year > 2027 || (year === 2027 && month >= 1)) {
        factor *= (1 + COGS_INFLATION_2027);
      }
      
      // Aplicar inflação de janeiro/2028 se já passou
      if(year > 2028 || (year === 2028 && month >= 1)) {
        factor *= (1 + COGS_INFLATION_2028);
      }
      
      // Aplicar inflação de janeiro/2029 se já passou
      if(year > 2029 || (year === 2029 && month >= 1)) {
        factor *= (1 + COGS_INFLATION_DEFAULT);
      }
      
      // Aplicar inflação de janeiro para cada ano após 2029
      if(year > 2029) {
        for(var y = 2030; y <= year; y++) {
          // Aplicar inflação se já passou de janeiro no ano atual, ou se é um ano anterior
          if(y < year || (y === year && month >= 1)) {
            factor *= (1 + COGS_INFLATION_DEFAULT);
          }
        }
      }
      
      return factor;
    }
    
    // Função para obter valor do Brent baseado no cenário e no ano
    // brentScenario: 'forward', 'bloomberg', ou 'custom'
    // year: ano
    // customBrent: valor customizado do Brent (usado apenas para cenário 'custom')
    function getBrentValue(brentScenario, year, customBrent) {
      if(brentScenario === 'forward') {
        // Curva forward
        if(year === 2026) return 60.58;
        if(year === 2027) return 62.18;
        if(year === 2028) return 64.05;
        if(year === 2029) return 65.78;
        if(year === 2030) return 67.15;
        if(year === 2031) return 68.04;
        if(year === 2032) return 68.54;
        if(year >= 2033) return 68.63;
        // Para anos anteriores a 2026, usar valor de 2026
        return 60.58;
      } else if(brentScenario === 'bloomberg') {
        // Média Bloomberg
        if(year === 2026) return 62.46;
        if(year === 2027) return 64.50;
        if(year >= 2028) return 70.00;
        // Para anos anteriores a 2026, usar valor de 2026
        return 62.46;
      } else if(brentScenario === 'custom') {
        // Customizado: usar valor do slider
        return customBrent || 62.0;
      }
      // Fallback
      return 62.0;
    }
    
    // Função para obter preço nominal em R$/m³ para um determinado ano/mês
    // isRealModel: se true, retorna PRICE_BASE sem inflação
    function getNominalPrice(year, month, isRealModel) {
      var factor = getPriceInflationFactor(year, month, isRealModel);
      return PRICE_BASE * factor;
    }
    
    // Função para obter preço baseado no cenário de preço
    // priceScenario: 'default', 'renegociado', ou 'brent'
    // year: ano (usado apenas para cenário 'default')
    // month: mês (usado apenas para cenário 'default')
    // brent: valor do Brent (usado apenas para cenário 'brent')
    // pctBrent: percentual do Brent (usado apenas para cenário 'brent')
    // useAverage: se true, retorna média ponderada do ano (apenas para cenário 'default')
    // isRealModel: se true, não aplica inflação
    function getPriceForScenario(priceScenario, year, month, brent, pctBrent, useAverage, isRealModel) {
      if(priceScenario === 'default') {
        // Cenário Default: aplica correção por inflação (se não for modelo real)
        if(useAverage) {
          return getAveragePriceForYear(year, isRealModel);
        } else {
          return getNominalPrice(year, month, isRealModel);
        }
      } else if(priceScenario === 'renegociado') {
        // Cenário Renegociado: R$ 1,90/m³ fixo durante todos os anos
        return 1.90;
      } else if(priceScenario === 'brent') {
        // Cenário % Brent: calcula como brent * % do Brent
        var priceUSDperMMBtu = brent * (Math.max(0, pctBrent) / 100);
        return (priceUSDperMMBtu * USD_BRL) / M3_PER_MMBTU;
      }
      // Fallback: retorna preço base
      return PRICE_BASE;
    }
    
    // Função para calcular preço médio ponderado do ano considerando inflação em junho
    // isRealModel: se true, não aplica inflação
    function getAveragePriceForYear(year, isRealModel) {
      // Calcular dias antes de junho (janeiro a maio)
      var daysBeforeJune = 0;
      for(var m = 1; m < 6; m++) {
        daysBeforeJune += getDaysInMonth(m, year);
      }
      // Calcular dias de junho em diante (junho a dezembro)
      var daysFromJune = 0;
      for(var m = 6; m <= 12; m++) {
        daysFromJune += getDaysInMonth(m, year);
      }
      
      // Preço antes de junho (sem inflação do ano atual)
      var priceBeforeJune = getNominalPrice(year, 5, isRealModel); // Maio (antes de junho)
      // Preço de junho em diante (com inflação do ano atual)
      var priceFromJune = getNominalPrice(year, 6, isRealModel); // Junho (com inflação)
      
      // Calcular preço médio ponderado
      var totalDays = daysBeforeJune + daysFromJune; // 365 ou 366 (ano bissexto)
      var avgPrice = (priceBeforeJune * daysBeforeJune + priceFromJune * daysFromJune) / totalDays;
      
      return avgPrice;
    }
    
    // Função para calcular receita bruta anual considerando variação de preço em junho
    function calculateAnnualGrossRevenue(year, totalVolumeM3, dailyVolumeM3, priceScenario, brent, pct, isRealModel) {
      // Calcular dias antes de junho (janeiro a maio)
      var daysBeforeJune = 0;
      for(var m = 1; m < 6; m++) {
        daysBeforeJune += getDaysInMonth(m, year);
      }
      // Calcular dias de junho em diante (junho a dezembro)
      var daysFromJune = 0;
      for(var m = 6; m <= 12; m++) {
        daysFromJune += getDaysInMonth(m, year);
      }
      
      var totalDays = daysBeforeJune + daysFromJune; // 365 ou 366 (ano bissexto)
      
      // Calcular volumes proporcionais baseados na distribuição de dias
      // Usar o volume total e distribuir proporcionalmente aos dias
      var volumeBeforeJune = (totalVolumeM3 * daysBeforeJune) / totalDays;
      var volumeFromJune = (totalVolumeM3 * daysFromJune) / totalDays;
      
      // Preços: para cenário "default", o preço varia em junho (inflação)
      // Para "renegociado" e "brent", o preço é fixo durante todo o ano
      var priceBeforeJune, priceFromJune;
      if(priceScenario === 'default') {
        // Cenário Default: preço varia em junho (inflação)
        priceBeforeJune = getPriceForScenario(priceScenario, year, 5, brent, pct, false, isRealModel); // Maio (antes de junho)
        priceFromJune = getPriceForScenario(priceScenario, year, 6, brent, pct, false, isRealModel); // Junho (com inflação)
      } else {
        // Cenário Renegociado ou Brent: preço fixo durante todo o ano
        var fixedPrice = getPriceForScenario(priceScenario, year, 6, brent, pct, false, isRealModel);
        priceBeforeJune = fixedPrice;
        priceFromJune = fixedPrice;
      }
      
      // Calcular receita bruta de cada período (com gross-up)
      var grossRevenueBeforeJune = calculateGrossRevenue(volumeBeforeJune, priceBeforeJune);
      var grossRevenueFromJune = calculateGrossRevenue(volumeFromJune, priceFromJune);
      
      // Receita bruta total
      return grossRevenueBeforeJune + grossRevenueFromJune;
    }
    
    // Função para obter COGS nominal anual para um determinado ano/mês
    // isRealModel: se true, retorna COGS_ANUAL_BASE sem inflação
    function getNominalCogs(year, month, isRealModel) {
      var factor = getCogsSgaInflationFactor(year, month, isRealModel);
      return COGS_ANUAL_BASE * factor;
    }
    
    // Função para obter SG&A nominal anual para um determinado ano/mês
    // isRealModel: se true, retorna SGA_ANUAL_BASE sem inflação
    function getNominalSga(year, month, isRealModel) {
      var factor = getCogsSgaInflationFactor(year, month, isRealModel);
      return SGA_ANUAL_BASE * factor;
    }
    
    // Reservas iniciais por categoria (em m³)
    var RESERVES_1P_INITIAL = 241.04 * 1_000_000; // 241,04 MMm³
    var RESERVES_1C_INITIAL = 121.27 * 1_000_000; // 121,27 MMm³
    var RESERVES_2C_INITIAL = 214.39 * 1_000_000; // 214,39 MMm³
    var RESERVES_3C_INITIAL = 415.42 * 1_000_000; // 415,42 MMm³
    
    // Função para obter reservas do cenário 1
    function getReservesC1(){
      var reservesMM = +document.getElementById('c1_reserves').value;
      return reservesMM * 1_000_000;
    }
    
    // Função para obter reservas do cenário 2
    function getReservesC2(){
      var reservesMM = +document.getElementById('c2_reserves').value;
      return reservesMM * 1_000_000;
    }
    
    // Função para obter teto de volume diário por ano (em m³/dia)
    function getDailyVolumeCeiling(year){
      if(year >= 2026 && year <= 2033){
        return 150000; // 150.000 m³/dia
      } else if(year === 2034){
        return 149630; // 149.630 m³/dia
      } else if(year === 2035){
        return 110710; // 110.710 m³/dia
      } else if(year === 2036){
        return 80200; // 80.200 m³/dia
      } else if(year === 2037 || year === 2038){
        return 80000; // 80.000 m³/dia
      } else if(year === 2039){
        return 72440; // 72.440 m³/dia
      } else if(year === 2040){
        return 48420; // 48.420 m³/dia
      } else if(year === 2041){
        return 39320; // 39.320 m³/dia
      } else if(year === 2042){
        return 31640; // 31.640 m³/dia
      } else if(year >= 2043 && year <= 2049){
        return 30000; // 30.000 m³/dia
      } else if(year === 2050){
        return 28550; // 28.550 m³/dia
      } else if(year === 2051){
        return 23510; // 23.510 m³/dia
      } else if(year === 2052){
        return 19180; // 19.180 m³/dia
      } else if(year === 2053){
        return 16530; // 16.530 m³/dia
      } else if(year === 2054){
        return 13920; // 13.920 m³/dia
      } else if(year >= 2055){
        return 11320; // 11.320 m³/dia (aplicado de 2055 até o último ano do modelo)
      }
      // Para anos antes de 2026, retornar um valor muito alto (sem teto efetivo)
      return 999999999;
    }
    
    // Constante para reservas mínimas necessárias em 2035
    var MIN_RESERVES_2035 = 21900000; // 21.900.000 m³ (60 mil m³/dia × 365 dias)
    
    // Função para calcular volume máximo permitido considerando reservas mínimas para 2035
    function getMaxVolumeForReservesConstraint(year, curveType, fullVolume, totalReserves, availableReserves) {
      // Aplicar restrição apenas para cenários 1P e 1P+1C com curva Full
      var reservesMM = totalReserves / 1_000_000;
      var is1POr1P1C = (reservesMM <= 362.31);
      
      if(!is1POr1P1C || curveType !== 'full') {
        // Não aplicar restrição
        return null;
      }
      
      // Em 2035, limitar produção a 60.000 m³/dia (necessário para o contrato)
      if(year === 2035) {
        var maxDailyVolume2035 = 60000; // 60 mil m³/dia
        // Garantir que não exceda as reservas disponíveis
        var daysInYear = getDaysInYear(2035);
        var maxProduction2035 = availableReserves;
        var maxDailyFromReserves = maxProduction2035 / daysInYear;
        return Math.min(maxDailyVolume2035, maxDailyFromReserves);
      }
      
      // Para anos anteriores a 2035, garantir que sobre reservas suficientes para 2035
      if(year > 2035) {
        // Não aplicar restrição para anos após 2035
        return null;
      }
      
      // Volume necessário para 2035: 60 mil m³/dia × 365 dias = 21.900.000 m³
      // Precisamos garantir que após todos os anos até 2034, sobre pelo menos MIN_RESERVES_2035
      
      // Calcular produção máxima permitida até 2034
      var maxProductionUntil2034 = totalReserves - MIN_RESERVES_2035;
      
      // Calcular quanto já foi produzido até agora
      var alreadyProduced = totalReserves - availableReserves;
      
      // Calcular quanto ainda pode ser produzido até 2034
      var remainingProductionAllowed = maxProductionUntil2034 - alreadyProduced;
      
      // Se não há mais produção permitida, retornar 0
      if(remainingProductionAllowed <= 0) {
        return 0;
      }
      
      // Calcular dias restantes até o final de 2034 (incluindo este ano)
      var daysUntilEndOf2034 = 0;
      for(var y = year; y <= 2034; y++) {
        daysUntilEndOf2034 += getDaysInYear(y);
      }
      
      // Distribuir a produção restante permitida pelos dias restantes até 2034
      // Isso garante que a produção seja distribuída uniformemente
      var maxDailyVolumeAverage = remainingProductionAllowed / daysUntilEndOf2034;
      
      // Retornar o volume diário máximo permitido
      // Se a produção atual (fullVolume * 1000) for menor que o máximo permitido, não limitar
      // Caso contrário, limitar ao máximo permitido
      return maxDailyVolumeAverage;
    }
    
    // Função para obter volume diário baseado no cenário de curva e no ano (Cenário 1)
    function getDailyVolumeC1(year, curveType, fullVolume, totalReserves, availableReserves){
      var volume = 0;
      if(curveType === 'full'){
        volume = fullVolume * 1000; // mil m³/dia para m³/dia
      } else if(curveType === 'qdc'){
        if(year >= 2026 && year <= 2035){
          volume = 40 * 1000; // 40 mil m³/dia
        }
      } else if(curveType === '3maq'){
        if(year >= 2026 && year <= 2027){
          volume = 40 * 1000; // 40 mil m³/dia
        } else if(year >= 2028 && year <= 2035){
          volume = 56 * 1000; // 56 mil m³/dia
        }
      } else if(curveType === 'qdcqdca'){
        if(year >= 2026 && year <= 2027){
          volume = 40 * 1000; // 40 mil m³/dia
        } else if(year >= 2028 && year <= 2032){
          volume = 80 * 1000; // 80 mil m³/dia
        } else if(year >= 2033 && year <= 2035){
          volume = 60 * 1000; // 60 mil m³/dia
        }
      }
      
      // Aplicar restrição de reservas para 2035 (apenas 1P e 1P+1C com curva Full)
      if(totalReserves !== undefined && availableReserves !== undefined) {
        var maxVolumeConstraint = getMaxVolumeForReservesConstraint(year, curveType, fullVolume, totalReserves, availableReserves);
        if(maxVolumeConstraint !== null) {
          volume = Math.min(volume, maxVolumeConstraint);
        }
      }
      
      // Aplicar teto de volume diário
      var ceiling = getDailyVolumeCeiling(year);
      return Math.min(volume, ceiling);
    }
    
    // Função para obter volume diário baseado no cenário de curva e no ano (Cenário 2)
    function getDailyVolumeC2(year, curveType, fullVolume, totalReserves, availableReserves){
      var volume = 0;
      if(curveType === 'full'){
        volume = fullVolume * 1000; // mil m³/dia para m³/dia
      } else if(curveType === 'qdc'){
        if(year >= 2026 && year <= 2035){
          volume = 40 * 1000; // 40 mil m³/dia
        }
      } else if(curveType === '3maq'){
        if(year >= 2026 && year <= 2027){
          volume = 40 * 1000; // 40 mil m³/dia
        } else if(year >= 2028 && year <= 2035){
          volume = 56 * 1000; // 56 mil m³/dia
        }
      } else if(curveType === 'qdcqdca'){
        if(year >= 2026 && year <= 2027){
          volume = 40 * 1000; // 40 mil m³/dia
        } else if(year >= 2028 && year <= 2032){
          volume = 80 * 1000; // 80 mil m³/dia
        } else if(year >= 2033 && year <= 2035){
          volume = 60 * 1000; // 60 mil m³/dia
        }
      }
      
      // Aplicar restrição de reservas para 2035 (apenas 1P e 1P+1C com curva Full)
      if(totalReserves !== undefined && availableReserves !== undefined) {
        var maxVolumeConstraint = getMaxVolumeForReservesConstraint(year, curveType, fullVolume, totalReserves, availableReserves);
        if(maxVolumeConstraint !== null) {
          volume = Math.min(volume, maxVolumeConstraint);
        }
      }
      
      // Aplicar teto de volume diário
      var ceiling = getDailyVolumeCeiling(year);
      return Math.min(volume, ceiling);
    }

    // Formatadores
    function nf2(v){ return (v||0).toLocaleString('pt-BR', {minimumFractionDigits:2, maximumFractionDigits:2}); }
    function nf0(v){ return (v||0).toLocaleString('pt-BR', {maximumFractionDigits:0}); }
    function nf4(v){ return (v||0).toLocaleString('pt-BR', {minimumFractionDigits:4, maximumFractionDigits:4}); }
    function pf1(v){ return (v||0).toLocaleString('pt-BR', {minimumFractionDigits:1, maximumFractionDigits:1}); }
    function pf2(v){ return (v||0).toLocaleString('pt-BR', {minimumFractionDigits:2, maximumFractionDigits:2}); }
    function formatMultiple(v){ return (v||0).toLocaleString('pt-BR', {minimumFractionDigits:1, maximumFractionDigits:1}) + 'x'; }

    // XIRR robusto (prioriza raiz positiva)
    function xirr(cfs, ts){
      if(!cfs || cfs.length===0) return null;
      var hasPos=false, hasNeg=false;
      for(var i=0;i<cfs.length;i++){ if(cfs[i]>0) hasPos=true; if(cfs[i]<0) hasNeg=true; }
      if(!(hasPos && hasNeg)) return null;

      function f(r){
        var s=0;
        for(var i=0;i<cfs.length;i++){ s += cfs[i]/Math.pow(1+r, ts[i]); }
        return s;
      }
      function df(r){
        var s=0;
        for(var i=0;i<cfs.length;i++){ s += (-ts[i]) * cfs[i]/Math.pow(1+r, ts[i]+1); }
        return s;
      }

      // 1) Newton com chutes positivos
      var guesses = [0.10,0.15,0.20,0.30,0.50];
      for(var gIdx=0; gIdx<guesses.length; gIdx++){
        var r = guesses[gIdx];
        for(var it=0; it<100; it++){
          var fr = f(r);
          if(!isFinite(fr)) break;
          if(Math.abs(fr) < 1e-10) return r;
          var dfr = df(r);
          if(!isFinite(dfr) || Math.abs(dfr) < 1e-14) break;
          r = r - fr/dfr;
          if(r <= -0.99) r = -0.99 + 1e-9;
          if(r > 10) r = 10;
        }
      }

      // 2) Bisseção positiva
      function bisect(lo, hi){
        var fLo = f(lo), fHi = f(hi);
        if(!isFinite(fLo) || !isFinite(fHi)) return null;
        if(fLo*fHi>0) return null;
        for(var it=0; it<200; it++){
          var mid = 0.5*(lo+hi);
          var fm = f(mid);
          if(!isFinite(fm)) return null;
          if(Math.abs(fm) < 1e-10) return mid;
          if(fLo*fm <= 0){ hi=mid; fHi=fm; } else { lo=mid; fLo=fm; }
        }
        return 0.5*(lo+hi);
      }

      var lastX = 0.0, lastF = f(lastX);
      if(isFinite(lastF)){
        for(var x=0.01; x<=10.0; x+=0.01){
          var fx = f(x);
          if(isFinite(fx) && lastF*fx <= 0){
            var root = bisect(lastX, x);
            if(root!=null) return root;
          }
          lastX = x; lastF = fx;
        }
      }

      // 3) Região negativa (fallback)
      lastX = -0.99; lastF = f(lastX);
      if(isFinite(lastF)){
        for(var x2=-0.98; x2<0.0; x2+=0.01){
          var fx2 = f(x2);
          if(isFinite(fx2) && lastF*fx2 <= 0){
            var root2 = bisect(lastX, x2);
            if(root2!=null) return root2;
          }
          lastX = x2; lastF = fx2;
        }
      }
      return null;
    }

    // ---------- Cenário 1 ----------
    function recalcC1(){
      try{
        var reservesMM = +document.getElementById('c1_reserves').value;
        var RESERVES_M3 = getReservesC1();
        var prodK = +document.getElementById('c1_prod').value;
        var curveType = document.getElementById('c1_curve').value;
        var modelType = document.getElementById('c1_model').value;
        var isRealModel = (modelType === 'real');
        var priceScenario = document.getElementById('c1_price_scenario').value;
        var brentScenario = document.getElementById('c1_brent_scenario').value;
        var customBrent = +document.getElementById('c1_brent').value;
        var brent = getBrentValue(brentScenario, START_YEAR, customBrent); // Valor inicial para exibição
        var pct   = +document.getElementById('c1_pct').value;
        var abd   = +document.getElementById('c1_abd').value;
        var capex = +document.getElementById('c1_capex').value;
        var buy   = +document.getElementById('c1_buy').value;
        var kePct = +document.getElementById('c1_ke').value;
        var decayOn = document.getElementById('c1_decay_on').checked;
        var decayPct = +document.getElementById('c1_decay').value;
        
        document.getElementById('c1_reserves_lbl').textContent = nf2(reservesMM);
        document.getElementById('c1_reserves_note').textContent = nf2(reservesMM);
        document.getElementById('reserves_display').textContent = nf2(reservesMM);
        
        // Atualizar label do dropdown de curva
        var curveLabels = {'qdc': 'QDC', '3maq': '3 máquinas', 'qdcqdca': 'QDC + QDCA', 'full': 'Full'};
        document.getElementById('c1_curve_lbl').textContent = curveLabels[curveType];
        
        // Habilitar/desabilitar slider de produção baseado no cenário
        var prodSlider = document.getElementById('c1_prod');
        var prodLabel = document.getElementById('c1_prod_label');
        if(curveType === 'full'){
          prodSlider.disabled = false;
          prodLabel.textContent = 'Produção no cenário Full';
        } else {
          prodSlider.disabled = true;
          prodLabel.textContent = 'Produção no cenário Full (não aplicável)';
        }
        
        // Atualizar label do dropdown de modelo
        var modelLabels = {'nominal': 'Nominal', 'real': 'Real'};
        document.getElementById('c1_model_lbl').textContent = modelLabels[modelType];
        
        // Atualizar label do dropdown de preço
        var priceLabels = {'default': 'Default', 'renegociado': 'Renegociado', 'brent': '% Brent'};
        document.getElementById('c1_price_scenario_lbl').textContent = priceLabels[priceScenario];
        
        // Atualizar label do dropdown de Brent
        var brentLabels = {'forward': 'Curva forward', 'bloomberg': 'Média Bloomberg', 'custom': 'Customizado'};
        document.getElementById('c1_brent_scenario_lbl').textContent = brentLabels[brentScenario];
        
        // Habilitar/desabilitar controles de % Brent baseado no cenário de preço
        var brentPriceBox = document.getElementById('c1_brent_price_box');
        if(priceScenario === 'brent'){
          brentPriceBox.style.display = 'block';
        } else {
          brentPriceBox.style.display = 'none';
        }
        
        // Habilitar/desabilitar slider customizado de Brent baseado no cenário
        var brentCustomBox = document.getElementById('c1_brent_custom_box');
        if(brentScenario === 'custom'){
          brentCustomBox.style.display = 'block';
        } else {
          brentCustomBox.style.display = 'none';
        }

        document.getElementById('c1_prod_lbl').textContent = nf0(prodK);
        document.getElementById('c1_brent_lbl').textContent = nf2(brent);
        document.getElementById('c1_brent_lbl2').textContent = nf2(brent);
        document.getElementById('c1_pct_lbl').textContent = pf1(pct);
        document.getElementById('c1_abd_lbl').textContent  = nf2(abd);
        document.getElementById('c1_capex_lbl').textContent= nf2(capex);
        document.getElementById('c1_buy_lbl').textContent  = nf2(buy);
        document.getElementById('c1_ke_lbl').textContent   = pf1(kePct);
        document.getElementById('c1_decay_lbl').textContent = pf2(decayPct);

        var decayBox = document.getElementById('c1_decay_box');
        decayBox.style.opacity = decayOn ? '1' : '.55';
        decayBox.style.pointerEvents = decayOn ? 'auto' : 'none';

        var ke = Math.max(0, kePct)/100;
        
        // Calcular preço em R$/m³ baseado no cenário
        var priceBRLperM3 = 0;
        var priceUSDperMMBtu = 0;
        var pricePctBrent = 0;
        
        // Calcular preço médio do modelo (usando preço do primeiro ano como referência)
        // Usar função que considera o cenário de preço
        var priceBRLperM3FirstYear = getPriceForScenario(priceScenario, START_YEAR, 6, brent, pct, false, isRealModel);
        pricePctBrent = brent > 0 ? ((priceBRLperM3FirstYear * M3_PER_MMBTU) / USD_BRL / brent) * 100 : 0;
        
        document.getElementById('c1_price_usd_lbl').textContent = nf2((priceBRLperM3FirstYear * M3_PER_MMBTU) / USD_BRL);
        document.getElementById('c1_price_pct').textContent = pf1(pricePctBrent);
        document.getElementById('c1_price_usd').textContent = nf2((priceBRLperM3FirstYear * M3_PER_MMBTU) / USD_BRL);
        document.getElementById('c1_price_brl').textContent = nf2(priceBRLperM3FirstYear);

        var decayRate = decayOn ? Math.max(0, Math.min(50, decayPct))/100 : 0;

        // Simulação ano a ano com volumes variáveis e decaimento
        var availableReserves = RESERVES_M3;
        var years = [];
        var producedTotalM3 = 0;
        var currentYear = START_YEAR;
        var maxYears = 100; // Limite de segurança (aumentado para permitir esgotar reservas maiores com tetos baixos)
        
        for(var yearIdx = 0; yearIdx < maxYears && availableReserves > 0; yearIdx++){
          var year = START_YEAR + yearIdx;
          var dailyM3 = getDailyVolumeC1(year, curveType, prodK, RESERVES_M3, availableReserves);
          
          if(dailyM3 <= 0) break; // Se não há produção definida para este ano, parar
          
          var daysInYear = getDaysInYear(year);
          var annualM3 = dailyM3 * daysInYear;
          var yearProduced = Math.min(annualM3, availableReserves);
          var frac = yearProduced / annualM3;
          
          // Se não há mais reservas suficientes para produzir, parar
          if(availableReserves < 1) break;
          
          // Calcular valores nominais para este ano
          // Obter valor do Brent para este ano baseado no cenário
          var brentForYear = getBrentValue(brentScenario, year, customBrent);
          // Para preço, usar função que considera o cenário de preço
          var nominalPrice = getPriceForScenario(priceScenario, year, 6, brentForYear, pct, true, isRealModel);
          var nominalCogs = getNominalCogs(year, 6, isRealModel);
          var nominalSga = getNominalSga(year, 6, isRealModel);
          
          // Calcular receita (com gross-up e tributos sobre faturamento)
          // Determinar regime tributário baseado na receita bruta do ano anterior
          var previousYearGrossRevenue = (yearIdx > 0 && years[yearIdx - 1]) ? years[yearIdx - 1].grossRevenue : 0;
          var isLucroReal = determineTaxRegime(previousYearGrossRevenue);
          
          // Usar cálculo anual que considera variação de preço em junho
          var grossRevenue = calculateAnnualGrossRevenue(year, yearProduced, dailyM3, priceScenario, brentForYear, pct, isRealModel);
          var turnoverTaxes = calculateTurnoverTaxes(grossRevenue, isLucroReal);
          var netRevenue = grossRevenue - turnoverTaxes;
          
          var grossRevenueMi = grossRevenue / 1_000_000;
          var turnoverTaxesMi = turnoverTaxes / 1_000_000;
          var revenueMi = netRevenue / 1_000_000; // Receita líquida em milhões
          
          // Royalties e Maintenance CapEx calculados sobre receita bruta
          var royaltiesMi = ROYALTY_RATE * grossRevenueMi;
          var maintenanceCapexMi = grossRevenueMi * MAINTENANCE_CAPEX_RATE;
          
          var cogsMi = (nominalCogs * frac) / 1_000_000;
          var sgaMi = (nominalSga * frac) / 1_000_000;
          var leasingMi = (LEASING_ANUAL * frac) / 1_000_000;
          
          // EBITDA = Receita líquida - Royalties - COGS - SG&A
          var ebitdaMi = revenueMi - royaltiesMi - cogsMi - sgaMi;
          // EBT = EBITDA - Leasing (leasing é despesa financeira)
          var ebtMi = ebitdaMi - leasingMi;
          // Tributos sobre lucro (considerando regime tributário)
          var taxesMi = calculateProfitTaxes(ebtMi * 1_000_000, grossRevenue, isLucroReal) / 1_000_000;
          // Lucro líquido = EBT - Tributos
          var netProfitMi = ebtMi - taxesMi;
          var netProfitAnual = netProfitMi * 1_000_000; // Converter para R$
          
          // Calcular lucro líquido mensal médio (dividir por 12 meses)
          var netProfitMensal = netProfitAnual / 12;
          
          // Corte econômico: se lucro líquido mensal < valor ajustado pela inflação, parar produção
          // Usar mês 6 (meio do ano) como referência para o cálculo do threshold
          var minProfitThreshold = getMinProfitThreshold(year, 6, isRealModel);
          if(netProfitMensal < minProfitThreshold && yearProduced > 0){
            break;
          }
          
          availableReserves -= yearProduced;
          producedTotalM3 += yearProduced;
          
          // Aplicar decaimento ao final do ano (se habilitado)
          var reservesAfterDecay = availableReserves;
          if(decayOn && decayRate > 0 && availableReserves > 0){
            availableReserves = availableReserves * (1 - decayRate);
            reservesAfterDecay = availableReserves;
          }
          
          // Calcular valores para armazenar
          var turnoverTaxes = calculateTurnoverTaxes(grossRevenue, isLucroReal);
          var netRevenue = grossRevenue - turnoverTaxes;
          var revenueMi = netRevenue / 1_000_000; // Receita líquida em milhões
          var grossRevenueMi = grossRevenue / 1_000_000;
          var royaltiesMi = ROYALTY_RATE * grossRevenueMi;
          var maintenanceCapexMi = grossRevenueMi * MAINTENANCE_CAPEX_RATE;
          var cogsMi = (nominalCogs * frac) / 1_000_000;
          var sgaMi = (nominalSga * frac) / 1_000_000;
          var leasingMi = (LEASING_ANUAL * frac) / 1_000_000;
          var ebitdaMi = revenueMi - royaltiesMi - cogsMi - sgaMi;
          var ebtMi = ebitdaMi - leasingMi;
          var taxesMi = calculateProfitTaxes(ebtMi * 1_000_000, grossRevenue, isLucroReal) / 1_000_000;
          var capexMi = (yearIdx === 0 ? Math.max(0,capex) : 0);
          var totalCapexMi = capexMi + maintenanceCapexMi;
          // FCFE sem abandono (abandono será aplicado apenas no último ano, calculado depois)
          var fcfeMi = ebitdaMi - leasingMi - taxesMi - totalCapexMi;
          
          years.push({
            produced: yearProduced,
            frac: frac,
            remaining: reservesAfterDecay,
            year: year,
            dailyM3: dailyM3,
            grossRevenue: grossRevenue, // Armazenar receita bruta para determinar regime do próximo ano
            revenueMi: revenueMi, // Receita líquida em milhões
            ebitdaMi: ebitdaMi, // EBITDA em milhões
            fcfeMi: fcfeMi, // FCFE em milhões (sem abandono, será ajustado depois)
            isLastYear: false // Será atualizado depois
          });
          
          // Se não há mais reservas após decaimento, parar
          if(availableReserves < 1) break;
        }
        
        var nYears = years.length;
        
        // Ajustar FCFE do último ano para considerar abandono
        if(nYears > 0){
          var lastYearData = years[nYears - 1];
          var abdMi = Math.max(0, abd);
          lastYearData.fcfeMi = lastYearData.fcfeMi - abdMi;
        }

        var npvMi = 0;
        var totalRevenueMi = 0;
        var totalEbitdaMi = 0;
        var tbody = document.getElementById('c1_tbody');
        tbody.innerHTML = "";
        var times=[], cfs=[];

        // Armazenar dados do cenário 1
        currentC1Data = years;
        
        // Atualizar gráficos se o cenário 1 estiver ativo
        if(currentActiveScenario === 'c1'){
          updateVolumeChart(years);
          updateReservesChart(years);
          updateRevenueChart(years);
          updateFcfeChart(years);
        }

        for(var i=0; i<nYears; i++){
          var yearData = years[i];
          var isLast = (i === nYears - 1);
          var frac = yearData.frac;
          var year = yearData.year;
          var reservesRemainingMiM3 = yearData.remaining / 1_000_000;
          
          // Calcular valores nominais para este ano
          // Obter valor do Brent para este ano baseado no cenário
          var brentForYear = getBrentValue(brentScenario, year, customBrent);
          // Para preço, usar função que considera o cenário de preço
          var nominalPrice = getPriceForScenario(priceScenario, year, 6, brentForYear, pct, true, isRealModel);
          var nominalCogs = getNominalCogs(year, 6, isRealModel);
          var nominalSga = getNominalSga(year, 6, isRealModel);
          
          // Calcular receita (com gross-up e tributos sobre faturamento)
          // Determinar regime tributário baseado na receita bruta do ano anterior
          var previousYearGrossRevenue = (i > 0 && years[i - 1]) ? years[i - 1].grossRevenue : 0;
          var isLucroReal = determineTaxRegime(previousYearGrossRevenue);
          
          // Usar receita bruta armazenada ou calcular se não existir
          var grossRevenue = yearData.grossRevenue || calculateAnnualGrossRevenue(year, yearData.produced, yearData.dailyM3, priceScenario, brentForYear, pct, isRealModel);
          var turnoverTaxes = calculateTurnoverTaxes(grossRevenue, isLucroReal);
          var netRevenue = grossRevenue - turnoverTaxes;
          
          var grossRevenueMi = grossRevenue / 1_000_000;
          var turnoverTaxesMi = turnoverTaxes / 1_000_000;
          var revenueMi = netRevenue / 1_000_000; // Receita líquida em milhões
          totalRevenueMi += revenueMi;

          // Royalties e Maintenance CapEx calculados sobre receita bruta
          var royaltiesMi = ROYALTY_RATE * grossRevenueMi;
          var maintenanceCapexMi = grossRevenueMi * MAINTENANCE_CAPEX_RATE;
          
          // COGS e SG&A proporcionais à fração do ano (valores nominais)
          var cogsMi = (nominalCogs * frac) / 1_000_000;
          var sgaMi = (nominalSga * frac) / 1_000_000;
          var leasingMi = (LEASING_ANUAL * frac) / 1_000_000;
          
          // EBITDA = Receita líquida - Royalties - COGS - SG&A
          var ebitdaMi = revenueMi - royaltiesMi - cogsMi - sgaMi;
          totalEbitdaMi += ebitdaMi;

          var abdMi = isLast ? Math.max(0,abd) : 0;

          // EBT = EBITDA - Leasing (leasing é despesa financeira)
          var ebtMi = ebitdaMi - leasingMi;
          // Tributos sobre lucro (considerando regime tributário)
          var taxesMi = calculateProfitTaxes(ebtMi * 1_000_000, grossRevenue, isLucroReal) / 1_000_000;

          var capexMi = (i===0 ? Math.max(0,capex) : 0);
          // Incluir Maintenance CapEx no Capex total
          var totalCapexMi = capexMi + maintenanceCapexMi;
          // FCFE = Lucro Líquido - Capex - Abandono = (EBITDA - Leasing - Tributos) - Capex - Abandono
          // Leasing é despesa financeira que reduz o caixa
          var fcfeMi = ebitdaMi - leasingMi - taxesMi - totalCapexMi - abdMi;

          var exp = isLast && frac < 1 ? (i + frac) : (i + 1);
          // Calcular Ke nominal para este ano (baseado na inflação do ano)
          var keNominal = calculateNominalKe(ke, year, isRealModel);
          var pvMi = fcfeMi / Math.pow(1+keNominal, exp);
          npvMi += pvMi;

          times.push(exp);
          cfs.push(fcfeMi);

          var tr = document.createElement('tr');
          function td(v){ var x=document.createElement('td'); x.textContent=v; return x; }
          var prodMediaDiaria = yearData.dailyM3; // m³/dia
          tr.appendChild(td(year));
          tr.appendChild(td(frac.toFixed(3)));
          tr.appendChild(td(nf2(reservesRemainingMiM3)));
          tr.appendChild(td(nf0(prodMediaDiaria/1000))); // Convertendo para mil m³/dia para exibição
          tr.appendChild(td(nf2(nominalPrice)));
          tr.appendChild(td(nf2(revenueMi)));
          tr.appendChild(td(nf2(royaltiesMi)));
          tr.appendChild(td(nf2(ebitdaMi)));
          tr.appendChild(td(nf2(abdMi)));
          tr.appendChild(td(nf2(taxesMi)));
          tr.appendChild(td(nf2(totalCapexMi)));
          tr.appendChild(td(nf2(fcfeMi)));
          tr.appendChild(td(nf2(pvMi)));
          tbody.appendChild(tr);
        }

        if(nYears===0){
          // Calcular Ke nominal para o primeiro ano
          var keNominalFirstYear = calculateNominalKe(ke, START_YEAR, isRealModel);
          npvMi = -Math.max(0,capex) / Math.pow(1+keNominalFirstYear, 1);
          // Adicionar capex aos arrays para cálculo da TIR (ano 1, tempo 1)
          if(capex > 0){
            cfs.push(-Math.max(0, capex));
            times.push(1);
          }
          var tr2 = document.createElement('tr');
          tr2.innerHTML = '<td colspan="13" class="small">Sem produção. NPV considera Capex no ano 1, descontado a Ke nominal. Compra em t0 não descontada.</td>';
          tbody.appendChild(tr2);
        }

        // Subtrair preço de compra em t0 (sem desconto)
        npvMi -= Math.max(0, buy);

        document.getElementById('c1_npv').textContent = nf2(npvMi);

        // Calcular EV/EBITDA implícito
        var evEbitdaImpl = '—';
        var ebitda2028 = null;
        var ebitda2028YearIdx = -1;
        var ebitda2028Frac = 0;
        for(var j=0; j<years.length; j++){
          if(years[j].year === 2028){
            ebitda2028 = years[j].ebitdaMi;
            ebitda2028YearIdx = j;
            ebitda2028Frac = years[j].frac;
            break;
          }
        }
        if(ebitda2028 !== null && ebitda2028 > 0 && npvMi !== 0){
          // Calcular o Present Value do EBITDA de 2028 usando a mesma mecânica de desconto do FCFE
          var year2028 = 2028;
          var isLast2028 = (ebitda2028YearIdx === years.length - 1);
          // Mesma lógica usada para o FCFE: exp = isLast && frac < 1 ? (i + frac) : (i + 1)
          var exp2028 = isLast2028 && ebitda2028Frac < 1 ? (ebitda2028YearIdx + ebitda2028Frac) : (ebitda2028YearIdx + 1);
          var keNominal2028 = calculateNominalKe(ke, year2028, isRealModel);
          var pvEbitda2028 = ebitda2028 / Math.pow(1+keNominal2028, exp2028);
          if(pvEbitda2028 > 0){
            evEbitdaImpl = formatMultiple(npvMi / pvEbitda2028);
          }
        }
        document.getElementById('c1_ev_ebitda').textContent = evEbitdaImpl;

        var reservasConsumidasMiM3 = producedTotalM3/1_000_000;
        var totalDays = 0;
        for(var j=0; j<years.length; j++){
          var yearDays = getDaysInYear(years[j].year);
          totalDays += years[j].frac * yearDays;
        }
        var volMedioK = totalDays > 0 ? (producedTotalM3/totalDays)/1000 : 0;
        var lastYear = nYears > 0 ? years[years.length - 1].year : '—';

        document.getElementById('c1_res').textContent = nf2(reservasConsumidasMiM3);
        document.getElementById('c1_volmed').textContent = nf0(volMedioK);
        document.getElementById('c1_lastyear').textContent = lastYear;
        
        // Calcular margem EBITDA média (soma dos EBITDAs / soma das receitas)
        var ebitdaMarginPct = totalRevenueMi > 0 ? (totalEbitdaMi / totalRevenueMi) * 100 : 0;
        document.getElementById('c1_ebitda_margin').textContent = totalRevenueMi > 0 ? (pf2(ebitdaMarginPct) + '%') : '—';

        var irrTxt = '—';
        if((capex>0 || buy>0) && (cfs.length>0 || buy>0)){
          // Criar cópias dos arrays para incluir o preço de compra em t0
          var cfsWithBuy = [];
          var timesWithBuy = [];
          
          // Adicionar preço de compra em t0 (tempo 0, fluxo negativo)
          if(buy > 0){
            cfsWithBuy.push(-Math.max(0, buy));
            timesWithBuy.push(0);
          }
          
          // Adicionar os demais fluxos de caixa
          for(var k=0; k<cfs.length; k++){
            cfsWithBuy.push(cfs[k]);
            timesWithBuy.push(times[k]);
          }
          
          if(cfsWithBuy.length > 0){
            var irr = xirr(cfsWithBuy, timesWithBuy);
            if(irr!=null) irrTxt = pf2(irr*100)+'%';
          }
        }
        document.getElementById('c1_irr').textContent = irrTxt;
      }catch(e){
        console.error('Erro C1:', e);
      }
    }

    // ---------- Cenário 2 ----------
    function recalcC2(){
      try{
        var reservesMM = +document.getElementById('c2_reserves').value;
        var totalResM3 = getReservesC2();
        var prodK = +document.getElementById('c2_prod').value;
        var curveType = document.getElementById('c2_curve').value;
        var modelType = document.getElementById('c2_model').value;
        var isRealModel = (modelType === 'real');
        var priceScenario = document.getElementById('c2_price_scenario').value;
        var brentScenario = document.getElementById('c2_brent_scenario').value;
        var customBrent = +document.getElementById('c2_brent').value;
        var brent = getBrentValue(brentScenario, START_YEAR, customBrent); // Valor inicial para exibição
        var pct   = +document.getElementById('c2_pct').value;
        var abd   = +document.getElementById('c2_abd').value;
        var capex = +document.getElementById('c2_capex').value;
        var build = Math.max(0, Math.min(36, Math.round(+document.getElementById('c2_build').value)));
        var debtOn = document.getElementById('c2_debt_on').checked;
        var debtPct = +document.getElementById('c2_debt_pct').value;
        var grace = Math.max(0, Math.min(24, Math.round(+document.getElementById('c2_grace').value)));
        var maturity = Math.max(0, Math.min(120, Math.round(+document.getElementById('c2_maturity').value)));
        var ratePct = +document.getElementById('c2_rate').value;
        var kePct = +document.getElementById('c2_ke').value;
        var decayOn = document.getElementById('c2_decay_on').checked;
        var decayPct = +document.getElementById('c2_decay').value;
        
        document.getElementById('c2_reserves_lbl').textContent = nf2(reservesMM);
        document.getElementById('c2_reserves_note').textContent = nf2(reservesMM);
        document.getElementById('reserves_display').textContent = nf2(reservesMM);
        
        // Atualizar label do dropdown de curva
        var curveLabels = {'qdc': 'QDC', '3maq': '3 máquinas', 'qdcqdca': 'QDC + QDCA', 'full': 'Full'};
        document.getElementById('c2_curve_lbl').textContent = curveLabels[curveType];
        
        // Habilitar/desabilitar slider de produção baseado no cenário
        var prodSlider = document.getElementById('c2_prod');
        var prodLabel = document.getElementById('c2_prod_label');
        if(curveType === 'full'){
          prodSlider.disabled = false;
          prodLabel.textContent = 'Produção no cenário Full';
        } else {
          prodSlider.disabled = true;
          prodLabel.textContent = 'Produção no cenário Full (não aplicável)';
        }
        
        // Atualizar label do dropdown de modelo
        var modelLabels = {'nominal': 'Nominal', 'real': 'Real'};
        document.getElementById('c2_model_lbl').textContent = modelLabels[modelType];
        
        // Atualizar label do dropdown de preço
        var priceLabels = {'default': 'Default', 'renegociado': 'Renegociado', 'brent': '% Brent'};
        document.getElementById('c2_price_scenario_lbl').textContent = priceLabels[priceScenario];
        
        // Atualizar label do dropdown de Brent
        var brentLabels = {'forward': 'Curva forward', 'bloomberg': 'Média Bloomberg', 'custom': 'Customizado'};
        document.getElementById('c2_brent_scenario_lbl').textContent = brentLabels[brentScenario];
        
        // Habilitar/desabilitar controles de % Brent baseado no cenário de preço
        var brentPriceBox = document.getElementById('c2_brent_price_box');
        if(priceScenario === 'brent'){
          brentPriceBox.style.display = 'block';
        } else {
          brentPriceBox.style.display = 'none';
        }
        
        // Habilitar/desabilitar slider customizado de Brent baseado no cenário
        var brentCustomBox = document.getElementById('c2_brent_custom_box');
        if(brentScenario === 'custom'){
          brentCustomBox.style.display = 'block';
        } else {
          brentCustomBox.style.display = 'none';
        }

        document.getElementById('c2_prod_lbl').textContent = nf0(prodK);
        document.getElementById('c2_brent_lbl').textContent = nf2(brent);
        document.getElementById('c2_brent_lbl2').textContent = nf2(brent);
        document.getElementById('c2_pct_lbl').textContent   = pf1(pct);
        document.getElementById('c2_abd_lbl').textContent   = nf2(abd);
        document.getElementById('c2_capex_lbl').textContent = nf2(capex);
        document.getElementById('c2_build_lbl').textContent = nf0(build);
        document.getElementById('c2_debt_pct_lbl').textContent = nf0(debtPct);
        document.getElementById('c2_grace_lbl').textContent = nf0(grace);
        document.getElementById('c2_maturity_lbl').textContent = nf0(maturity);
        document.getElementById('c2_rate_lbl').textContent  = pf1(ratePct);
        document.getElementById('c2_ke_lbl').textContent    = pf1(kePct);
        document.getElementById('c2_decay_lbl').textContent = pf2(decayPct);

        var debtBox = document.getElementById('debt_box');
        debtBox.style.opacity = debtOn ? '1' : '.55';
        debtBox.style.pointerEvents = debtOn ? 'auto' : 'none';

        var decayBox = document.getElementById('c2_decay_box');
        decayBox.style.opacity = decayOn ? '1' : '.55';
        decayBox.style.pointerEvents = decayOn ? 'auto' : 'none';
        
        // Atualizar label do dropdown de preço
        var priceLabels = {'default': 'Default', 'renegociado': 'Renegociado', 'brent': '% Brent'};
        document.getElementById('c2_price_scenario_lbl').textContent = priceLabels[priceScenario];
        
        // Habilitar/desabilitar controles de % Brent baseado no cenário de preço
        var brentPriceBox = document.getElementById('c2_brent_price_box');
        if(priceScenario === 'brent'){
          brentPriceBox.style.display = 'block';
        } else {
          brentPriceBox.style.display = 'none';
        }

        var ke = Math.max(0, kePct)/100;
        
        // Calcular preço em R$/m³ baseado no cenário
        var priceBRLperM3 = 0;
        var priceUSDperMMBtu = 0;
        var pricePctBrent = 0;
        
        // Calcular preço médio do modelo (usando preço do primeiro mês de operação como referência)
        // Usar função que considera o cenário de preço
        var firstOpMonth = opStartM;
        var firstOpYear = START_YEAR + Math.floor(firstOpMonth / 12);
        var firstOpMonthInYear = (firstOpMonth % 12) + 1;
        var brentForFirstMonth = getBrentValue(brentScenario, firstOpYear, customBrent);
        var priceBRLperM3FirstMonth = getPriceForScenario(priceScenario, firstOpYear, firstOpMonthInYear, brentForFirstMonth, pct, false, isRealModel);
        pricePctBrent = brentForFirstMonth > 0 ? ((priceBRLperM3FirstMonth * M3_PER_MMBTU) / USD_BRL / brentForFirstMonth) * 100 : 0;
        
        document.getElementById('c2_price_pct').textContent = pf1(pricePctBrent);
        document.getElementById('c2_price_usd').textContent = nf2((priceBRLperM3FirstMonth * M3_PER_MMBTU) / USD_BRL);
        document.getElementById('c2_price_brl').textContent = nf2(priceBRLperM3FirstMonth);

        var capexMonths = Math.max(1, build), opStartM = build;
        var totalCapexMi = Math.max(0,capex), capexPerMonthMi = totalCapexMi/capexMonths;

        var depMonths = 120, depPerMonthMi = totalCapexMi/depMonths;

        var financedMi = debtOn ? (totalCapexMi*Math.max(0,Math.min(100,debtPct))/100) : 0;
        var debtRateMonthly = (Math.max(0,ratePct)/100)/12;
        var graceMonths = grace, maturityMonths = maturity, amortMonths = Math.max(0, maturityMonths - graceMonths);
        
        var decayRate = decayOn ? Math.max(0, Math.min(50, decayPct))/100 : 0;

        var month=0, producedM3=0, maxMonths=6000, debtOutstanding=0;
        var mTimesU=[], mCfsU=[], mTimesL=[], mCfsL=[], npvU=0, npvL=0;
        var yearMap = {};
        var availableReserves = totalResM3;
        var totalRevenueMiC2 = 0;
        var totalEbitdaMiC2 = 0;

        while(month<maxMonths && availableReserves > 0){
          var tYears = month/12;
          var year = START_YEAR + Math.floor(month/12);

          // Obter volume diário baseado no cenário de curva e no ano
          var dailyM3 = getDailyVolumeC2(year, curveType, prodK, totalResM3, availableReserves);
          // Calcular mês no ano (1-12)
          var monthInYear = (month % 12) + 1;
          var daysInThisMonth = getDaysInMonth(monthInYear, year);
          var monthlyM3 = dailyM3 * daysInThisMonth;

          var mProd=0;
          if(month>=opStartM && monthlyM3>0 && availableReserves > 0){
            mProd = Math.min(monthlyM3, availableReserves);
          }
          
          // Calcular valores nominais para este mês (monthInYear já foi calculado acima)
          // Obter valor do Brent para este ano baseado no cenário
          var brentForYear = getBrentValue(brentScenario, year, customBrent);
          // Para preço, usar função que considera o cenário de preço
          var nominalPrice = getPriceForScenario(priceScenario, year, monthInYear, brentForYear, pct, false, isRealModel);
          var nominalCogs = getNominalCogs(year, monthInYear, isRealModel);
          var nominalSga = getNominalSga(year, monthInYear, isRealModel);
          
          // Calcular receita (com gross-up e tributos sobre faturamento)
          // Determinar regime tributário baseado na receita bruta do ano anterior
          var previousYear = year - 1;
          var previousYearGrossRevenue = (previousYear >= START_YEAR && yearMap[previousYear]) ? 
            (yearMap[previousYear].grossRevenue || 0) : 0;
          var isLucroReal = determineTaxRegime(previousYearGrossRevenue);
          
          var grossRevenue = calculateGrossRevenue(mProd, nominalPrice);
          var turnoverTaxes = calculateTurnoverTaxes(grossRevenue, isLucroReal);
          var netRevenue = grossRevenue - turnoverTaxes;
          
          var grossRevenueMi = grossRevenue / 1_000_000;
          var turnoverTaxesMi = turnoverTaxes / 1_000_000;
          var revenueMi = netRevenue / 1_000_000; // Receita líquida em milhões
          
          // Royalties e Maintenance CapEx calculados sobre receita bruta
          var royaltiesMi = ROYALTY_RATE * grossRevenueMi;
          var maintenanceCapexMi = grossRevenueMi * MAINTENANCE_CAPEX_RATE;
          
          // Calcular valores mensais proporcionais aos dias do mês
          var daysInYear = getDaysInYear(year);
          var cogsMi = (nominalCogs * daysInThisMonth / daysInYear) / 1_000_000;
          var sgaMi = (nominalSga * daysInThisMonth / daysInYear) / 1_000_000;
          var leasingMi = (LEASING_ANUAL * daysInThisMonth / daysInYear) / 1_000_000;
          
          var capexThis = (month<capexMonths) ? capexPerMonthMi : 0;
          // Incluir Maintenance CapEx no Capex total
          var totalCapexThis = capexThis + maintenanceCapexMi;
          
          // EBITDA = Receita líquida - Royalties - COGS - SG&A
          var ebitdaMi = revenueMi - royaltiesMi - cogsMi - sgaMi;
          // EBT = EBITDA - Leasing (leasing é despesa financeira)
          var ebtMi = ebitdaMi - leasingMi;
          // Tributos sobre lucro (considerando regime tributário)
          var taxesMi = calculateProfitTaxes(ebtMi * 1_000_000, grossRevenue, isLucroReal) / 1_000_000;
          // Lucro líquido = EBT - Tributos
          var netProfitMi = ebtMi - taxesMi;
          var netProfit = netProfitMi * 1_000_000; // Converter para R$
          
          // Corte econômico: se lucro líquido < valor ajustado pela inflação, parar produção
          var minProfitThreshold = getMinProfitThreshold(year, monthInYear, isRealModel);
          if(mProd > 0 && netProfit < minProfitThreshold){
            break;
          }
          
          // Se passou no corte econômico, subtrair das reservas
          if(mProd > 0){
            availableReserves -= mProd;
          producedM3 += mProd;
          }
          
          // Aplicar decaimento ao final de cada ano (ao final do mês 11, 23, 35, etc.)
          if(decayOn && decayRate > 0 && month > 0 && (month + 1) % 12 === 0 && availableReserves > 0){
            availableReserves = availableReserves * (1 - decayRate);
          }

          // Acumular receita e EBITDA apenas quando há produção
          if(mProd > 0){
            totalRevenueMiC2 += revenueMi;
            totalEbitdaMiC2 += ebitdaMi;
          }

          var depMi = (month>=opStartM && month<opStartM+depMonths) ? depPerMonthMi : 0;

          var isLastOp = (availableReserves <= 0 && mProd > 0);
          var abdCashMi = isLastOp ? Math.max(0,abd) : 0;

          // Dívida
          var drawMi=0, interestMi=0, principalMi=0;
          if(debtOn){
            var financedThis = (month<capexMonths) ? (financedMi/capexMonths) : 0;
            drawMi = financedThis;
            var interestBase = debtOutstanding;
            interestMi = interestBase>0 ? interestBase*debtRateMonthly : 0;
            debtOutstanding += drawMi;

            if(month>=graceMonths && month<maturityMonths){
              if(amortMonths>0){
                var remainingMonths = maturityMonths - Math.max(month, graceMonths);
                principalMi = debtOutstanding/remainingMonths;
              } else {
                if(month===graceMonths) principalMi = debtOutstanding;
              }
            } else if(month>=maturityMonths && debtOutstanding>0){
              principalMi = debtOutstanding;
            }
            debtOutstanding = Math.max(0, debtOutstanding - principalMi);
          }

          // DRE sem abandono
          // EBT = EBITDA - Depreciação - Leasing (leasing é despesa financeira)
          var ebtUnlev = ebitdaMi - depMi - leasingMi;
          // Tributos sobre lucro (considerando regime tributário) - desalavancado
          var taxUnlev = calculateProfitTaxes(ebtUnlev * 1_000_000, grossRevenue, isLucroReal) / 1_000_000;
          var netIncUnlev = ebtUnlev - taxUnlev;

          var ebtLev = ebtUnlev - interestMi;
          // Tributos sobre lucro (considerando regime tributário) - alavancado
          var taxLev = calculateProfitTaxes(ebtLev * 1_000_000, grossRevenue, isLucroReal) / 1_000_000;
          var netIncLev = ebtLev - taxLev;

          // FCFE (abandono apenas em caixa)
          var fcfeU = netIncUnlev + depMi - totalCapexThis - abdCashMi;
          var netBorrow = drawMi - principalMi;
          var fcfeL = netIncLev + depMi - totalCapexThis + netBorrow - abdCashMi;

          // Calcular Ke nominal para este ano (baseado na inflação do ano)
          var keNominal = calculateNominalKe(ke, year, isRealModel);
          var pvU = fcfeU/Math.pow(1+keNominal, tYears);
          var pvL = fcfeL/Math.pow(1+keNominal, tYears);
          npvU += pvU; npvL += pvL;

          mTimesU.push(tYears); mCfsU.push(fcfeU);
          mTimesL.push(tYears); mCfsL.push(fcfeL);

          var year = START_YEAR + Math.floor(month/12);
          if(!yearMap[year]){
            yearMap[year] = {frac:0,revenue:0,royalties:0,ebitda:0,aband:0,taxes:0,capex:0,fcfe:0,pv:0,reservesRemaining:0,producedM3:0,grossRevenue:0};
          }
          var ym = yearMap[year];
          ym.revenue += revenueMi;
          ym.royalties += royaltiesMi;
          ym.ebitda += ebitdaMi;
          ym.aband += abdCashMi;
          ym.taxes += taxUnlev;
          ym.capex += totalCapexThis;
          ym.fcfe += fcfeU;
          ym.pv += pvU;
          ym.producedM3 += mProd; // Acumular produção mensal
          ym.grossRevenue += grossRevenue; // Acumular receita bruta para determinar regime do próximo ano
          ym.grossRevenue += grossRevenue; // Acumular receita bruta para determinar regime do próximo ano
          if(monthlyM3>0 && mProd>0){
            // Calcular fração do ano baseada nos dias reais do mês
            var daysInThisMonth = getDaysInMonth(monthInYear, year);
            var daysInYear = getDaysInYear(year);
            ym.frac += (Math.min(1, mProd/monthlyM3) * daysInThisMonth) / daysInYear;
          }
          
          // Atualizar reservas restantes ao final de cada ano (após decaimento)
          if((month + 1) % 12 === 0 || availableReserves <= 0){
            ym.reservesRemaining = availableReserves;
          }

          month++;
        }

        var irrU = xirr(mCfsU, mTimesU);
        var irrL = xirr(mCfsL, mTimesL);

        document.getElementById('c2_irr_unlev').textContent = irrU!=null ? (pf2(irrU*100)+'%') : '—';
        document.getElementById('c2_irr_lev').textContent = irrL!=null ? (pf2(irrL*100)+'%') : '—';

        document.getElementById('c2_npv_unlev').textContent = nf2(npvU);
        document.getElementById('c2_npv_lev').textContent = nf2(npvL);

        // Calcular EV/EBITDA implícito (usando NPV desalavancado)
        var evEbitdaImplC2 = '—';
        if(yearMap[2028] && yearMap[2028].ebitda > 0 && npvU !== 0){
          // Calcular o Present Value do EBITDA de 2028 usando a mesma mecânica de desconto do FCFE
          var year2028 = 2028;
          // O EBITDA de 2028 no yearMap é acumulado ao longo do ano
          // Vamos usar o mês médio de 2028 para o desconto (aproximadamente mês 30, considerando meio do ano)
          // O primeiro mês de 2028 seria: (2028 - START_YEAR) * 12 = 24 meses
          // O mês médio seria aproximadamente: 24 + 6 = 30 meses
          var month2028Start = (2028 - START_YEAR) * 12; // Mês inicial de 2028
          var month2028Mid = month2028Start + 6; // Mês médio de 2028 (aproximado)
          var tYears2028 = month2028Mid / 12; // Mesma lógica usada para o FCFE (tYears = month/12)
          var keNominal2028 = calculateNominalKe(ke, year2028, isRealModel);
          var pvEbitda2028 = yearMap[2028].ebitda / Math.pow(1+keNominal2028, tYears2028);
          if(pvEbitda2028 > 0){
            evEbitdaImplC2 = formatMultiple(npvU / pvEbitda2028);
          }
        }
        document.getElementById('c2_ev_ebitda').textContent = evEbitdaImplC2;

        var opMonths = Math.max(0, month - build);
        // Calcular total de dias de operação somando os dias corretos de cada mês
        var totalDays = 0;
        if(opMonths > 0) {
          for(var m = build; m < month; m++) {
            var mYear = START_YEAR + Math.floor(m / 12);
            var mMonthInYear = (m % 12) + 1;
            totalDays += getDaysInMonth(mMonthInYear, mYear);
          }
        }
        var volMedK = totalDays > 0 ? (producedM3 / totalDays) / 1000 : 0;
        var lastYear = opMonths>0 ? (START_YEAR + Math.floor((build + opMonths - 1)/12)) : '—';

        document.getElementById('c2_volmed').textContent = nf0(volMedK);
        document.getElementById('c2_res').textContent = nf2(producedM3/1_000_000);
        document.getElementById('c2_lastyear').textContent = lastYear;
        
        // Calcular margem EBITDA média (soma dos EBITDAs / soma das receitas)
        var ebitdaMarginPctC2 = totalRevenueMiC2 > 0 ? (totalEbitdaMiC2 / totalRevenueMiC2) * 100 : 0;
        document.getElementById('c2_ebitda_margin').textContent = totalRevenueMiC2 > 0 ? (pf2(ebitdaMarginPctC2) + '%') : '—';

        var tbody2 = document.getElementById('c2_tbody');
        tbody2.innerHTML = '';
        var yearKeys = Object.keys(yearMap).map(function(k){ return +k; }).sort(function(a,b){ return a-b; });
        
        // Garantir que o último ano tenha as reservas restantes atualizadas
        if(yearKeys.length > 0){
          var lastYearKey = yearKeys[yearKeys.length - 1];
          if(yearMap[lastYearKey]){
            yearMap[lastYearKey].reservesRemaining = availableReserves;
          }
        }
        if(yearKeys.length===0){
          var trEmpty=document.createElement('tr');
          trEmpty.innerHTML='<td colspan="13" class="small">Sem dados.</td>';
          tbody2.appendChild(trEmpty);
        }else{
          yearKeys.forEach(function(y){
            var data = yearMap[y];
            var tr=document.createElement('tr');
            function td(val){ var cell=document.createElement('td'); cell.textContent=val; return cell; }
            var reservesRemainingMiM3 = data.reservesRemaining / 1_000_000;
            // Calcular produção média diária: produção total / (dias do ano * fração)
            var yearDays = getDaysInYear(y);
            var diasAno = data.frac * yearDays;
            var prodMediaDiaria = diasAno > 0 ? (data.producedM3 / diasAno) : 0; // m³/dia
            // Calcular preço médio nominal do ano (usando mês 6 como referência)
            // Obter valor do Brent para este ano baseado no cenário
            var brentForYear = getBrentValue(brentScenario, y, customBrent);
            // Para preço, usar função que considera o cenário de preço
            var avgNominalPrice = getPriceForScenario(priceScenario, y, 6, brentForYear, pct, true);
            tr.appendChild(td(y));
            tr.appendChild(td(data.frac.toFixed(3)));
            tr.appendChild(td(nf2(reservesRemainingMiM3)));
            tr.appendChild(td(nf0(prodMediaDiaria/1000))); // Convertendo para mil m³/dia para exibição
            tr.appendChild(td(nf2(avgNominalPrice)));
            tr.appendChild(td(nf2(data.revenue)));
            tr.appendChild(td(nf2(data.royalties)));
            tr.appendChild(td(nf2(data.ebitda)));
            tr.appendChild(td(nf2(data.aband)));
            tr.appendChild(td(nf2(data.taxes)));
            tr.appendChild(td(nf2(data.capex)));
            tr.appendChild(td(nf2(data.fcfe)));
            tr.appendChild(td(nf2(data.pv)));
            tbody2.appendChild(tr);
          });
        }
        
        // Converter yearMap para formato years array e armazenar
        var c2YearsArray = [];
        yearKeys.forEach(function(y){
          var data = yearMap[y];
          var yearDays = getDaysInYear(y);
          c2YearsArray.push({
            year: y,
            produced: data.producedM3 || 0,
            dailyM3: data.producedM3 > 0 ? (data.producedM3 / (data.frac * yearDays)) : 0,
            remaining: data.reservesRemaining || 0,
            frac: data.frac || 0,
            revenueMi: data.revenue || 0, // Receita líquida em milhões
            ebitdaMi: data.ebitda || 0, // EBITDA em milhões
            fcfeMi: data.fcfe || 0 // FCFE em milhões
          });
        });
        currentC2Data = c2YearsArray;
        
        // Atualizar gráficos se o cenário 2 estiver ativo
        if(currentActiveScenario === 'c2'){
          updateVolumeChart(c2YearsArray);
          updateReservesChart(c2YearsArray);
          updateRevenueChart(c2YearsArray);
          updateFcfeChart(c2YearsArray);
        }

      }catch(e){
        console.error('Erro C2:', e);
      }
    }

    // Bind
    function bindInputs(){
      ['c1_reserves','c1_curve','c1_model','c1_price_scenario','c1_brent_scenario','c1_prod','c1_brent','c1_pct','c1_abd','c1_capex','c1_buy','c1_ke','c1_decay']
        .forEach(function(id){ var el=document.getElementById(id); el.addEventListener('input', recalcC1); el.addEventListener('change', recalcC1); });

      ['c2_reserves','c2_curve','c2_model','c2_price_scenario','c2_brent_scenario','c2_prod','c2_brent','c2_pct','c2_abd','c2_capex','c2_build','c2_debt_pct','c2_grace','c2_maturity','c2_rate','c2_ke','c2_decay']
        .forEach(function(id){ var el=document.getElementById(id); el.addEventListener('input', recalcC2); el.addEventListener('change', recalcC2); });

      document.getElementById('c1_decay_on').addEventListener('change', recalcC1);
      document.getElementById('c2_debt_on').addEventListener('change', recalcC2);
      document.getElementById('c2_decay_on').addEventListener('change', recalcC2);

      document.getElementById('resetBtn').addEventListener('click', function(){
        // Defaults C1
        document.getElementById('c1_reserves').value=992.12; // 1P+3C como padrão
        document.getElementById('c1_curve').value='full';
        document.getElementById('c1_model').value='nominal';
        document.getElementById('c1_price_scenario').value='default';
        document.getElementById('c1_brent_scenario').value='forward';
        document.getElementById('c1_prod').value=150;
        document.getElementById('c1_brent').value=62.0;
        document.getElementById('c1_pct').value=10;
        document.getElementById('c1_abd').value=50;
        document.getElementById('c1_capex').value=0;
        document.getElementById('c1_buy').value=0;
        document.getElementById('c1_ke').value=25;
        document.getElementById('c1_decay_on').checked=false;
        document.getElementById('c1_decay').value=5;
        // Defaults C2
        document.getElementById('c2_reserves').value=992.12; // 1P+3C como padrão
        document.getElementById('c2_curve').value='full';
        document.getElementById('c2_model').value='nominal';
        document.getElementById('c2_price_scenario').value='default';
        document.getElementById('c2_brent_scenario').value='forward';
        document.getElementById('c2_prod').value=150;
        document.getElementById('c2_brent').value=62.0;
        document.getElementById('c2_pct').value=25;
        document.getElementById('c2_abd').value=50;
        document.getElementById('c2_capex').value=120;
        document.getElementById('c2_build').value=12;
        document.getElementById('c2_debt_on').checked=false;
        document.getElementById('c2_debt_pct').value=80;
        document.getElementById('c2_grace').value=12;
        document.getElementById('c2_maturity').value=60;
        document.getElementById('c2_rate').value=9;
        document.getElementById('c2_ke').value=25;
        document.getElementById('c2_decay_on').checked=false;
        document.getElementById('c2_decay').value=5;
        recalcC1(); recalcC2();
      });

      // Tabs
      var v1 = document.getElementById('view-venda');
      var v2 = document.getElementById('view-liq');
      var b1 = document.getElementById('tab-venda');
      var b2 = document.getElementById('tab-liq');
      b1.addEventListener('click', function(){
        b1.classList.add('active'); b2.classList.remove('active');
        v1.classList.remove('hidden'); v2.classList.add('hidden');
        currentActiveScenario = 'c1';
        // Atualizar gráficos com dados do cenário 1
        if(currentC1Data){
          updateVolumeChart(currentC1Data);
          updateReservesChart(currentC1Data);
          updateRevenueChart(currentC1Data);
          updateFcfeChart(currentC1Data);
        }
      });
      b2.addEventListener('click', function(){
        b2.classList.add('active'); b1.classList.remove('active');
        v2.classList.remove('hidden'); v1.classList.add('hidden');
        currentActiveScenario = 'c2';
        // Atualizar gráficos com dados do cenário 2
        if(currentC2Data){
          updateVolumeChart(currentC2Data);
          updateReservesChart(currentC2Data);
          updateRevenueChart(currentC2Data);
          updateFcfeChart(currentC2Data);
        }
      });
    }

    // Variáveis globais para armazenar dados dos cenários
    var currentC1Data = null;
    var currentC2Data = null;
    var currentActiveScenario = 'c1'; // 'c1' ou 'c2'
    
    // Gráfico de volumes
    var volumeChart = null;
    
    function getQDCVolume(year){
      if(year >= 2026 && year <= 2035){
        return 40 * 1000; // 40 mil m³/dia
      }
      return 0;
    }
    
    function getQDCAVolume(year){
      if(year >= 2028 && year <= 2032){
        return 40 * 1000; // 40 mil m³/dia
      } else if(year >= 2033 && year <= 2035){
        return 20 * 1000; // 20 mil m³/dia
      }
      return 0;
    }
    
    function initVolumeChart(){
      var ctx = document.getElementById('volumeChart');
      if(!ctx) return;
      
      volumeChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [
            {
              label: 'QDC',
              data: [],
              backgroundColor: 'rgba(54, 162, 235, 0.8)',
              stack: 'volumes',
              datalabels: {
                anchor: 'center',
                align: 'center',
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                formatter: function(value) {
                  if(value > 0) {
                    return Math.round(value / 1000);
                  }
                  return '';
                }
              }
            },
            {
              label: 'QDCA',
              data: [],
              backgroundColor: 'rgba(75, 192, 192, 0.8)',
              stack: 'volumes',
              datalabels: {
                anchor: 'center',
                align: 'center',
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                formatter: function(value) {
                  if(value > 0) {
                    return Math.round(value / 1000);
                  }
                  return '';
                }
              }
            },
            {
              label: 'Surplus Gas',
              data: [],
              backgroundColor: 'rgba(255, 159, 64, 0.8)',
              stack: 'volumes',
              datalabels: {
                anchor: 'center',
                align: 'center',
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                formatter: function(value, context) {
                  if(value > 0) {
                    return Math.round(value / 1000);
                  }
                  return '';
                }
              }
            },
            {
              type: 'line',
              label: 'Total',
              data: [],
              backgroundColor: 'transparent',
              borderColor: 'transparent',
              pointRadius: 0,
              pointHoverRadius: 0,
              borderWidth: 0,
              fill: false,
              datalabels: {
                anchor: 'center',
                align: 'top',
                color: '#000',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 8 : 12
                },
                formatter: function(value, context) {
                  // Usar o valor do próprio dataset (já é o total calculado)
                  if(value > 0) {
                    return Math.round(value / 1000);
                  }
                  return '';
                },
                display: function(context) {
                  return context.dataset.data[context.dataIndex] > 0;
                },
                offset: window.innerWidth <= 768 ? -3 : -5 // Offset para cima do topo da barra
              }
            }
          ]
        },
        plugins: [window.ChartDataLabels || ChartDataLabels],
        options: {
          responsive: true,
          maintainAspectRatio: false,
          resizeDelay: 0,
          datasets: {
            bar: {
              barThickness: window.innerWidth <= 768 ? 40 : 50,
              maxBarThickness: window.innerWidth <= 768 ? 50 : 60,
              categoryPercentage: window.innerWidth <= 768 ? 0.75 : 0.8,
              barPercentage: window.innerWidth <= 768 ? 0.85 : 0.9
            }
          },
          layout: {
            padding: {
              top: window.innerWidth <= 768 ? 30 : 10,
              bottom: window.innerWidth <= 768 ? 60 : 10,
              left: window.innerWidth <= 768 ? 20 : 5,
              right: window.innerWidth <= 768 ? 20 : 5
            }
          },
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                font: { 
                  size: window.innerWidth <= 768 ? 9 : 12,
                  weight: 'normal'
                },
                boxWidth: window.innerWidth <= 768 ? 10 : 15,
                padding: window.innerWidth <= 768 ? 6 : 10
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  var label = context.dataset.label || '';
                  var value = context.parsed.y || 0;
                  return label + ': ' + Math.round(value / 1000) + ' mil m³/dia';
                },
                footer: function(tooltipItems) {
                  var total = tooltipItems.reduce(function(sum, item) {
                    return sum + (item.parsed.y || 0);
                  }, 0);
                  return 'Total: ' + Math.round(total / 1000) + ' mil m³/dia';
                }
              }
            },
            title: {
              display: false
            },
            datalabels: {
              display: function(context) {
                var isMobile = window.innerWidth <= 768;
                // No mobile, mostrar apenas o dataset "Total" (índice 3)
                if(isMobile) {
                  if(context.datasetIndex === 3) {
                    var total = context.dataset.data[context.dataIndex] || 0;
                    return total > 0;
                  }
                  return false; // Desativar outros datasets no mobile
                }
                // No desktop, mostrar todos os datasets
                // Para o dataset de total (índice 3), sempre mostrar se houver total
                if(context.datasetIndex === 3) {
                  var total = context.dataset.data[context.dataIndex] || 0;
                  return total > 0;
                }
                // Para os outros datasets, mostrar se houver valor
                return context.dataset.data[context.dataIndex] > 0;
              }
            }
          },
          scales: {
            x: {
              stacked: true,
              title: {
                display: true,
                text: 'Ano',
                font: {
                  size: window.innerWidth <= 768 ? 10 : 12
                }
              },
              ticks: {
                font: { 
                  size: window.innerWidth <= 768 ? 10 : 11,
                  weight: 'normal'
                },
                maxRotation: 0,
                minRotation: 0,
                autoSkip: window.innerWidth <= 768 ? false : true,
                padding: window.innerWidth <= 768 ? 8 : 5
              }
            },
            y: {
              stacked: true,
              title: {
                display: true,
                text: 'Volume (m³/dia)',
                font: {
                  size: window.innerWidth <= 768 ? 10 : 12
                }
              },
              ticks: {
                callback: function(value) {
                  return Math.round(value / 1000) + 'k';
                },
                font: { 
                  size: window.innerWidth <= 768 ? 10 : 11,
                  weight: 'normal'
                },
                maxTicksLimit: window.innerWidth <= 768 ? 6 : 10,
                padding: window.innerWidth <= 768 ? 8 : 5
              }
            }
          },
        }
      });
    }
    
    function updateVolumeChart(yearsData){
      if(!volumeChart) {
        initVolumeChart();
        if(!volumeChart) return;
      }
      
      var labels = [];
      var qdcData = [];
      var qdcaData = [];
      var surplusData = [];
      
      for(var year = 2026; year <= 2040; year++){
        labels.push(year.toString());
        
        var qdc = getQDCVolume(year);
        var qdca = getQDCAVolume(year);
        
        // Encontrar o volume total deste ano nos dados
        var totalVolume = 0;
        if(yearsData && yearsData.length > 0){
          for(var i = 0; i < yearsData.length; i++){
            if(yearsData[i].year === year){
              totalVolume = yearsData[i].dailyM3 || 0;
              break;
            }
          }
        }
        
        var surplus = Math.max(0, totalVolume - qdc - qdca);
        
        qdcData.push(qdc);
        qdcaData.push(qdca);
        surplusData.push(surplus);
      }
      
      // Calcular totais para o dataset de labels
      var totalData = [];
      for(var i = 0; i < labels.length; i++){
        totalData.push(qdcData[i] + qdcaData[i] + surplusData[i]);
      }
      
      volumeChart.data.labels = labels;
      volumeChart.data.datasets[0].data = qdcData;
      volumeChart.data.datasets[1].data = qdcaData;
      volumeChart.data.datasets[2].data = surplusData;
      volumeChart.data.datasets[3].data = totalData; // Dataset de total para labels
      volumeChart.update();
    }
    
    // Gráfico de reservas
    var reservesChart = null;
    
    function initReservesChart(){
      var ctx = document.getElementById('reservesChart');
      if(!ctx) return;
      
      reservesChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [
            {
              label: '1P',
              data: [],
              backgroundColor: 'rgba(54, 162, 235, 0.8)',
              stack: 'reserves',
              datalabels: {
                anchor: 'center',
                align: 'center',
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                formatter: function(value) {
                  if(value > 0) {
                    return Math.round(value / 1_000_000);
                  }
                  return '';
                }
              }
            },
            {
              label: '1C',
              data: [],
              backgroundColor: 'rgba(75, 192, 192, 0.8)',
              stack: 'reserves',
              datalabels: {
                anchor: 'center',
                align: 'center',
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                formatter: function(value) {
                  if(value > 0) {
                    return Math.round(value / 1_000_000);
                  }
                  return '';
                }
              }
            },
            {
              label: '2C',
              data: [],
              backgroundColor: 'rgba(255, 206, 86, 0.8)',
              stack: 'reserves',
              datalabels: {
                anchor: 'center',
                align: 'center',
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                formatter: function(value) {
                  if(value > 0) {
                    return Math.round(value / 1_000_000);
                  }
                  return '';
                }
              }
            },
            {
              label: '3C',
              data: [],
              backgroundColor: 'rgba(255, 159, 64, 0.8)',
              stack: 'reserves',
              datalabels: {
                anchor: 'center',
                align: 'center',
                color: '#fff',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                formatter: function(value) {
                  if(value > 0) {
                    return Math.round(value / 1_000_000);
                  }
                  return '';
                }
              }
            },
            {
              type: 'line',
              label: 'Total',
              data: [],
              backgroundColor: 'transparent',
              borderColor: 'transparent',
              pointRadius: 0,
              pointHoverRadius: 0,
              borderWidth: 0,
              fill: false,
              datalabels: {
                anchor: 'center',
                align: 'top',
                color: '#000',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 10 : 12
                },
                formatter: function(value, context) {
                  // Usar o valor do próprio dataset (já é o total calculado)
                  if(value > 0) {
                    return Math.round(value / 1_000_000);
                  }
                  return '';
                },
                display: function(context) {
                  return context.dataset.data[context.dataIndex] > 0;
                },
                offset: window.innerWidth <= 768 ? -3 : -5 // Offset para cima do topo da barra
              }
            }
          ]
        },
        plugins: [window.ChartDataLabels || ChartDataLabels],
        options: {
          responsive: true,
          maintainAspectRatio: false,
          resizeDelay: 0,
          datasets: {
            bar: {
              barThickness: window.innerWidth <= 768 ? 40 : 50,
              maxBarThickness: window.innerWidth <= 768 ? 50 : 60,
              categoryPercentage: window.innerWidth <= 768 ? 0.75 : 0.8,
              barPercentage: window.innerWidth <= 768 ? 0.85 : 0.9
            }
          },
          layout: {
            padding: {
              top: window.innerWidth <= 768 ? 30 : 10,
              bottom: window.innerWidth <= 768 ? 60 : 10,
              left: window.innerWidth <= 768 ? 20 : 5,
              right: window.innerWidth <= 768 ? 20 : 5
            }
          },
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                font: { 
                  size: window.innerWidth <= 768 ? 9 : 12,
                  weight: 'normal'
                },
                boxWidth: window.innerWidth <= 768 ? 10 : 15,
                padding: window.innerWidth <= 768 ? 6 : 10
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  var label = context.dataset.label || '';
                  var value = context.parsed.y || 0;
                  return label + ': ' + (value / 1_000_000).toFixed(2) + ' MMm³';
                },
                footer: function(tooltipItems) {
                  var total = tooltipItems.reduce(function(sum, item) {
                    return sum + (item.parsed.y || 0);
                  }, 0);
                  return 'Total: ' + (total / 1_000_000).toFixed(2) + ' MMm³';
                }
              }
            },
            title: {
              display: false
            },
            datalabels: {
              display: function(context) {
                var isMobile = window.innerWidth <= 768;
                // No mobile, mostrar apenas o dataset "Total" (índice 4)
                if(isMobile) {
                  if(context.datasetIndex === 4) {
                    var total = context.dataset.data[context.dataIndex] || 0;
                    return total > 0;
                  }
                  return false; // Desativar outros datasets no mobile
                }
                // No desktop, mostrar todos os datasets
                // Para o dataset de total (índice 4), sempre mostrar se houver total
                if(context.datasetIndex === 4) {
                  var total = context.dataset.data[context.dataIndex] || 0;
                  return total > 0;
                }
                // Para os outros datasets, mostrar se houver valor
                return context.dataset.data[context.dataIndex] > 0;
              }
            }
          },
          scales: {
            x: {
              stacked: true,
              title: {
                display: true,
                text: 'Ano',
                font: {
                  size: window.innerWidth <= 768 ? 10 : 12
                }
              },
              ticks: {
                font: { 
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                maxRotation: 0,
                minRotation: 0,
                autoSkip: window.innerWidth <= 768 ? false : true,
                padding: window.innerWidth <= 768 ? 8 : 5
              }
            },
            y: {
              stacked: true,
              title: {
                display: true,
                text: 'Reservas (MMm³)',
                font: {
                  size: window.innerWidth <= 768 ? 10 : 12
                }
              },
              ticks: {
                callback: function(value) {
                  return (value / 1_000_000).toFixed(1);
                },
                font: { 
                  size: window.innerWidth <= 768 ? 10 : 11
                },
                maxTicksLimit: window.innerWidth <= 768 ? 5 : 10
              }
            }
          }
        }
      });
    }
    
    function updateReservesChart(yearsData){
      if(!reservesChart) {
        initReservesChart();
        if(!reservesChart) return;
      }
      
      var labels = [];
      var reserves1P = [];
      var reserves1C = [];
      var reserves2C = [];
      var reserves3C = [];
      
      // Obter reservas selecionadas do cenário ativo
      var selectedReservesMM = 0;
      if(currentActiveScenario === 'c1'){
        selectedReservesMM = +document.getElementById('c1_reserves').value;
      } else {
        selectedReservesMM = +document.getElementById('c2_reserves').value;
      }
      
      // Calcular reservas iniciais baseado na seleção
      // 1P: 241.04, 1P+1C: 362.31, 1P+2C: 576.70, 1P+3C: 992.12
      var totalSelected = selectedReservesMM * 1_000_000;
      var remaining1P = RESERVES_1P_INITIAL;
      var remaining1C = RESERVES_1C_INITIAL;
      var remaining2C = RESERVES_2C_INITIAL;
      var remaining3C = RESERVES_3C_INITIAL;
      
      // Ajustar reservas baseado na seleção
      if(selectedReservesMM <= 241.04){
        // Apenas 1P
        remaining1P = totalSelected;
        remaining1C = 0;
        remaining2C = 0;
        remaining3C = 0;
      } else if(selectedReservesMM <= 362.31){
        // 1P + 1C
        remaining1C = totalSelected - RESERVES_1P_INITIAL;
        remaining2C = 0;
        remaining3C = 0;
      } else if(selectedReservesMM <= 576.70){
        // 1P + 1C + 2C
        remaining1C = RESERVES_1C_INITIAL;
        remaining2C = totalSelected - RESERVES_1P_INITIAL - RESERVES_1C_INITIAL;
        remaining3C = 0;
      } else {
        // 1P + 1C + 2C + 3C
        remaining1C = RESERVES_1C_INITIAL;
        remaining2C = RESERVES_2C_INITIAL;
        remaining3C = totalSelected - RESERVES_1P_INITIAL - RESERVES_1C_INITIAL - RESERVES_2C_INITIAL;
      }
      
      // Processar cada ano
      for(var year = 2026; year <= 2040; year++){
        labels.push(year.toString());
        
        // Encontrar produção deste ano nos dados
        var yearProduced = 0;
        if(yearsData && yearsData.length > 0){
          for(var i = 0; i < yearsData.length; i++){
            if(yearsData[i].year === year){
              yearProduced = yearsData[i].produced || 0;
              break;
            }
          }
        }
        
        // Consumir reservas na ordem: 1P, depois 1C, depois 2C, depois 3C
        var toConsume = yearProduced;
        
        // Consumir 1P primeiro
        var consumed1P = Math.min(toConsume, remaining1P);
        remaining1P -= consumed1P;
        toConsume -= consumed1P;
        
        // Depois consumir 1C
        var consumed1C = Math.min(toConsume, remaining1C);
        remaining1C -= consumed1C;
        toConsume -= consumed1C;
        
        // Depois consumir 2C
        var consumed2C = Math.min(toConsume, remaining2C);
        remaining2C -= consumed2C;
        toConsume -= consumed2C;
        
        // Por último consumir 3C
        var consumed3C = Math.min(toConsume, remaining3C);
        remaining3C -= consumed3C;
        toConsume -= consumed3C;
        
        // Armazenar reservas restantes no final do ano
        reserves1P.push(remaining1P);
        reserves1C.push(remaining1C);
        reserves2C.push(remaining2C);
        reserves3C.push(remaining3C);
      }
      
      // Calcular totais para o dataset de labels
      var totalData = [];
      for(var i = 0; i < labels.length; i++){
        totalData.push(reserves1P[i] + reserves1C[i] + reserves2C[i] + reserves3C[i]);
      }
      
      reservesChart.data.labels = labels;
      reservesChart.data.datasets[0].data = reserves1P;
      reservesChart.data.datasets[1].data = reserves1C;
      reservesChart.data.datasets[2].data = reserves2C;
      reservesChart.data.datasets[3].data = reserves3C;
      reservesChart.data.datasets[4].data = totalData; // Dataset de total para labels
      reservesChart.update();
    }

    // Gráfico de Receita Líquida e Margem EBITDA
    var revenueChart = null;
    
    function initRevenueChart(){
      var ctx = document.getElementById('revenueChart');
      if(!ctx) return;
      
      revenueChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Receita Líquida (R$ mi)',
              data: [],
              backgroundColor: 'rgba(54, 162, 235, 0.8)',
              yAxisID: 'y',
              datalabels: {
                anchor: 'end',
                align: 'top',
                color: '#000',
                font: {
                  size: window.innerWidth <= 768 ? 9 : 11
                },
                formatter: function(value) {
                  if(value > 0) {
                    return value.toFixed(1);
                  }
                  return '';
                }
              }
            },
            {
              type: 'line',
              label: 'Margem EBITDA (%)',
              data: [],
              borderColor: 'rgba(255, 99, 132, 1)',
              backgroundColor: 'rgba(255, 99, 132, 0.1)',
              yAxisID: 'y1',
              borderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6,
              fill: false,
              tension: 0.1,
              datalabels: {
                anchor: 'end',
                align: 'top',
                color: 'rgba(255, 99, 132, 1)',
                font: {
                  weight: 'bold',
                  size: window.innerWidth <= 768 ? 9 : 11
                },
                formatter: function(value) {
                  if(value !== null && value !== undefined) {
                    return value.toFixed(1) + '%';
                  }
                  return '';
                }
              }
            }
          ]
        },
        plugins: [window.ChartDataLabels || ChartDataLabels],
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Receita Líquida (R$ milhões)',
                font: {
                  size: window.innerWidth <= 768 ? 10 : 12
                }
              },
              ticks: {
                font: {
                  size: window.innerWidth <= 768 ? 9 : 11
                }
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Margem EBITDA (%)',
                font: {
                  size: window.innerWidth <= 768 ? 10 : 12
                }
              },
              ticks: {
                font: {
                  size: window.innerWidth <= 768 ? 9 : 11
                }
              },
              grid: {
                drawOnChartArea: false,
              },
            },
            x: {
              ticks: {
                font: {
                  size: window.innerWidth <= 768 ? 9 : 11
                }
              }
            }
          },
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                font: { 
                  size: window.innerWidth <= 768 ? 9 : 12,
                  weight: 'normal'
                },
                boxWidth: window.innerWidth <= 768 ? 10 : 15,
                padding: window.innerWidth <= 768 ? 6 : 10
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  var label = context.dataset.label || '';
                  var value = context.parsed.y || 0;
                  if(context.datasetIndex === 0) {
                    return label + ': R$ ' + value.toFixed(2) + ' milhões';
                  } else {
                    return label + ': ' + value.toFixed(2) + '%';
                  }
                }
              }
            },
            title: {
              display: false
            }
          }
        }
      });
    }
    
    function updateRevenueChart(yearsData){
      if(!revenueChart) {
        initRevenueChart();
        if(!revenueChart) return;
      }
      
      var labels = [];
      var revenueData = [];
      var ebitdaMarginData = [];
      
      // Filtrar anos entre 2026 e 2040
      for(var i = 0; i < yearsData.length; i++){
        var year = yearsData[i].year;
        if(year >= 2026 && year <= 2040){
          labels.push(year);
          var revenueMi = yearsData[i].revenueMi || 0;
          var ebitdaMi = yearsData[i].ebitdaMi || 0;
          revenueData.push(revenueMi);
          // Calcular margem EBITDA (%)
          var margin = revenueMi > 0 ? (ebitdaMi / revenueMi) * 100 : 0;
          ebitdaMarginData.push(margin);
        }
      }
      
      // Preencher anos faltantes com 0
      for(var y = 2026; y <= 2040; y++){
        if(labels.indexOf(y) === -1){
          labels.push(y);
          revenueData.push(0);
          ebitdaMarginData.push(null);
        }
      }
      
      revenueChart.data.labels = labels;
      revenueChart.data.datasets[0].data = revenueData;
      revenueChart.data.datasets[1].data = ebitdaMarginData;
      revenueChart.update();
    }

    // Gráfico de FCFE Acumulado
    var fcfeChart = null;
    
    function initFcfeChart(){
      var ctx = document.getElementById('fcfeChart');
      if(!ctx) return;
      
      fcfeChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [
            {
              label: 'FCFE Acumulado (R$ mi)',
              data: [],
              backgroundColor: 'rgba(75, 192, 192, 0.8)',
              datalabels: {
                anchor: 'end',
                align: 'top',
                color: '#000',
                font: {
                  size: window.innerWidth <= 768 ? 9 : 11
                },
                formatter: function(value) {
                  if(value !== null && value !== undefined && value !== 0) {
                    return value.toFixed(1);
                  }
                  return '';
                }
              }
            }
          ]
        },
        plugins: [window.ChartDataLabels || ChartDataLabels],
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'FCFE Acumulado (R$ milhões)',
                font: {
                  size: window.innerWidth <= 768 ? 10 : 12
                }
              },
              ticks: {
                font: {
                  size: window.innerWidth <= 768 ? 9 : 11
                }
              }
            },
            x: {
              ticks: {
                font: {
                  size: window.innerWidth <= 768 ? 9 : 11
                }
              }
            }
          },
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                font: { 
                  size: window.innerWidth <= 768 ? 9 : 12,
                  weight: 'normal'
                },
                boxWidth: window.innerWidth <= 768 ? 10 : 15,
                padding: window.innerWidth <= 768 ? 6 : 10
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  var label = context.dataset.label || '';
                  var value = context.parsed.y || 0;
                  return label + ': R$ ' + value.toFixed(2) + ' milhões';
                }
              }
            },
            title: {
              display: false
            }
          }
        }
      });
    }
    
    function updateFcfeChart(yearsData){
      if(!fcfeChart) {
        initFcfeChart();
        if(!fcfeChart) return;
      }
      
      var labels = [];
      var fcfeAccumulatedData = [];
      var accumulatedFcfe = 0;
      
      // Filtrar anos entre 2026 e 2040 e calcular FCFE acumulado
      for(var i = 0; i < yearsData.length; i++){
        var year = yearsData[i].year;
        if(year >= 2026 && year <= 2040){
          labels.push(year);
          var fcfeMi = yearsData[i].fcfeMi || 0;
          accumulatedFcfe += fcfeMi;
          fcfeAccumulatedData.push(accumulatedFcfe);
        }
      }
      
      // Preencher anos faltantes com o último valor acumulado
      var lastValue = fcfeAccumulatedData.length > 0 ? fcfeAccumulatedData[fcfeAccumulatedData.length - 1] : 0;
      for(var y = 2026; y <= 2040; y++){
        if(labels.indexOf(y) === -1){
          labels.push(y);
          fcfeAccumulatedData.push(lastValue);
        }
      }
      
      fcfeChart.data.labels = labels;
      fcfeChart.data.datasets[0].data = fcfeAccumulatedData;
      fcfeChart.update();
    }

    // Variável para armazenar altura fixa dos cards em mobile
    var fixedKpiHeight = null;
    
    // Função para igualar altura dos cards ao preço médio em mobile
    function equalizeKpiHeights(){
      if(window.innerWidth > 768) {
        // Em desktop, remover min-height e resetar altura fixa
        var allKpis = document.querySelectorAll('.kpi');
        allKpis.forEach(function(kpi){
          kpi.style.minHeight = '';
          kpi.style.height = '';
        });
        fixedKpiHeight = null;
        return;
      }
      
      var kpiContainers = document.querySelectorAll('.kpis');
      kpiContainers.forEach(function(container){
        var priceBox = container.querySelector('.kpi.priceBox');
        if(priceBox){
          // Se ainda não temos altura fixa, calcular uma vez
          if(fixedKpiHeight === null){
            // Primeiro, remover qualquer altura definida anteriormente
            var allKpis = container.querySelectorAll('.kpi');
            allKpis.forEach(function(kpi){
              kpi.style.minHeight = '';
              kpi.style.height = '';
            });
            // Forçar reflow para medir altura natural
            void priceBox.offsetHeight;
            // Calcular altura baseada no conteúdo do priceBox (usando scrollHeight para pegar altura real)
            // Adicionar um pequeno buffer para garantir que caiba todo o conteúdo
            fixedKpiHeight = priceBox.scrollHeight;
          }
          
          // Aplicar altura fixa a todos os cards (sempre a mesma, nunca incrementar)
          var allKpis = container.querySelectorAll('.kpi');
          allKpis.forEach(function(kpi){
            // Sempre usar o mesmo valor fixo, nunca incrementar
            kpi.style.height = fixedKpiHeight + 'px';
            kpi.style.minHeight = fixedKpiHeight + 'px';
            kpi.style.maxHeight = fixedKpiHeight + 'px';
          });
        }
      });
    }
    
    // Listener para redimensionamento da janela (atualizar gráficos em mobile)
    var resizeTimeout;
    window.addEventListener('resize', function(){
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(function(){
        if(volumeChart){
          volumeChart.resize();
          volumeChart.update('none'); // Atualizar sem animação para recalcular datalabels
        }
        if(reservesChart){
          reservesChart.resize();
          reservesChart.update('none'); // Atualizar sem animação para recalcular datalabels
        }
        if(revenueChart){
          revenueChart.resize();
          revenueChart.update('none');
        }
        if(fcfeChart){
          fcfeChart.resize();
          fcfeChart.update('none');
        }
        // Não chamar equalizeKpiHeights aqui para evitar crescimento incremental
      }, 250);
    });
    
    // Igualar altura dos cards apenas uma vez após carregar
    setTimeout(function(){
      equalizeKpiHeights();
    }, 200);
    
    // Resetar altura fixa quando a janela é redimensionada (mobile <-> desktop)
    var resizeTimeout2;
    window.addEventListener('resize', function(){
      clearTimeout(resizeTimeout2);
      resizeTimeout2 = setTimeout(function(){
        if(window.innerWidth <= 768 && fixedKpiHeight === null){
          // Se voltou para mobile e não tem altura fixa, recalcular
          setTimeout(equalizeKpiHeights, 100);
        } else if(window.innerWidth > 768){
          // Se voltou para desktop, resetar altura fixa
          fixedKpiHeight = null;
          var allKpis = document.querySelectorAll('.kpi');
          allKpis.forEach(function(kpi){
            kpi.style.height = '';
            kpi.style.minHeight = '';
          });
        }
      }, 100);
    });

    // ResizeObserver para redimensionar gráficos quando o container mudar
    var volumeResizeObserver = null;
    var reservesResizeObserver = null;
    var revenueResizeObserver = null;
    var fcfeResizeObserver = null;
    
    function setupChartResizeObservers(){
      var volumeContainer = document.getElementById('volumeChartContainer');
      var reservesContainer = document.getElementById('reservesChartContainer');
      var revenueContainer = document.getElementById('revenueChartContainer');
      var fcfeContainer = document.getElementById('fcfeChartContainer');
      
      // Limpar observadores anteriores se existirem
      if(volumeResizeObserver){
        volumeResizeObserver.disconnect();
      }
      if(reservesResizeObserver){
        reservesResizeObserver.disconnect();
      }
      if(revenueResizeObserver){
        revenueResizeObserver.disconnect();
      }
      if(fcfeResizeObserver){
        fcfeResizeObserver.disconnect();
      }
      
      if(volumeContainer && volumeChart){
        volumeResizeObserver = new ResizeObserver(function(entries){
          if(volumeChart){
            // Usar requestAnimationFrame para garantir que o DOM esteja atualizado
            requestAnimationFrame(function(){
              volumeChart.resize();
              volumeChart.update('none');
            });
          }
        });
        volumeResizeObserver.observe(volumeContainer);
      }
      
      if(reservesContainer && reservesChart){
        reservesResizeObserver = new ResizeObserver(function(entries){
          if(reservesChart){
            // Usar requestAnimationFrame para garantir que o DOM esteja atualizado
            requestAnimationFrame(function(){
              reservesChart.resize();
              reservesChart.update('none');
            });
          }
        });
        reservesResizeObserver.observe(reservesContainer);
      }
      
      if(revenueContainer && revenueChart){
        revenueResizeObserver = new ResizeObserver(function(entries){
          if(revenueChart){
            requestAnimationFrame(function(){
              revenueChart.resize();
              revenueChart.update('none');
            });
          }
        });
        revenueResizeObserver.observe(revenueContainer);
      }
      
      if(fcfeContainer && fcfeChart){
        fcfeResizeObserver = new ResizeObserver(function(entries){
          if(fcfeChart){
            requestAnimationFrame(function(){
              fcfeChart.resize();
              fcfeChart.update('none');
            });
          }
        });
        fcfeResizeObserver.observe(fcfeContainer);
      }
    }

    // Init
    (function(){
      bindInputs();
      initVolumeChart();
      initReservesChart();
      initRevenueChart();
      initFcfeChart();
      recalcC1(); recalcC2();
      // Configurar ResizeObserver após inicialização dos gráficos
      setTimeout(setupChartResizeObservers, 100);
    })();
  </script>
</body>
</html>
